Directory structure:
└── backend/
    ├── Dockerfile
    ├── create_admin.py
    ├── nodemon.json
    ├── package.json
    ├── pyproject.toml
    ├── qc
    ├── query
    ├── requirements.txt
    ├── run_server.py
    ├── server.js
    ├── simple_test.py
    ├── .env.backup
    ├── app/
    │   ├── __init__.py
    │   ├── config.py
    │   ├── database.py
    │   ├── dependencies.py
    │   ├── dns_proxy.py
    │   ├── dns_proxy_manager.py
    │   ├── firewall_driver.py
    │   ├── firewall_os.py
    │   ├── linux_firewall.py
    │   ├── log_watchers.py
    │   ├── main.py
    │   ├── middleware.py
    │   ├── models.py
    │   ├── schemas.py
    │   ├── settings.py
    │   ├── win_firewall.py
    │   ├── __pycache__/
    │   ├── routers/
    │   │   ├── __init__.py
    │   │   ├── auth.py
    │   │   ├── auth_simple.py
    │   │   ├── backup.py
    │   │   ├── dns.py
    │   │   ├── firewall.py
    │   │   ├── firewall_groups.py
    │   │   ├── layer7_inspect.py
    │   │   ├── logs.py
    │   │   ├── nat.py
    │   │   ├── network.py
    │   │   ├── reports.py
    │   │   ├── routes.py
    │   │   ├── settings.py
    │   │   ├── settings_router.py
    │   │   ├── status.py
    │   │   ├── system.py
    │   │   └── __pycache__/
    │   ├── services/
    │   │   ├── firewall_service.py
    │   │   └── __pycache__/
    │   └── tasks/
    │       ├── __init__.py
    │       ├── cleanup.py
    │       ├── firewall_sync.py
    │       ├── health_monitor.py
    │       ├── log_watcher.py
    │       └── __pycache__/
    ├── logs/
    ├── middleware/
    │   ├── auth.js
    │   ├── dataRetention.js
    │   └── errorHandler.js
    ├── models/
    │   ├── FirewallRule.js
    │   ├── NetworkActivity.js
    │   ├── SystemStats.js
    │   └── User.js
    ├── routes/
    │   ├── auth.js
    │   ├── dashboard.js
    │   ├── firewall.js
    │   ├── logs.js
    │   ├── nat.js
    │   ├── security.js
    │   ├── settings.js
    │   ├── system.js
    │   └── users.js
    ├── services/
    │   └── dataCollectionService.js
    └── utils/
        └── logger.js

================================================
File: Dockerfile
================================================
# Multi-stage build for production optimization
FROM python:3.11-slim as builder

# Set build arguments
ARG BUILD_ENV=production

# Set environment variables
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Create virtual environment
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --upgrade pip && \
    pip install -r requirements.txt

# Production stage
FROM python:3.11-slim as production

# Set environment variables
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PATH="/opt/venv/bin:$PATH"

# Install runtime dependencies
RUN apt-get update && apt-get install -y \
    curl \
    iptables \
    netsh \
    && rm -rf /var/lib/apt/lists/* \
    && useradd --create-home --shell /bin/bash app

# Copy virtual environment from builder stage
COPY --from=builder /opt/venv /opt/venv

# Set working directory
WORKDIR /app

# Copy application code
COPY --chown=app:app . .

# Create necessary directories
RUN mkdir -p logs data && \
    chown -R app:app /app

# Switch to non-root user
USER app

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Expose port
EXPOSE 8000

# Run the application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "1"]


================================================
File: create_admin.py
================================================
#!/usr/bin/env python3
"""
KOBI Firewall - Database Initialization & Admin Creation
Modern async implementation with comprehensive error handling
"""
import asyncio
import sys
import os
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any

# Add backend directory to path
sys.path.append(str(Path(__file__).parent))

from motor.motor_asyncio import AsyncIOMotorClient
from passlib.context import CryptContext
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.panel import Panel
from rich.table import Table

from app.settings import get_settings

# Initialize rich console and crypto context
console = Console()
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
settings = get_settings()


class DatabaseInitializer:
    """Modern database initialization with comprehensive setup"""

    def __init__(self):
        self.client = AsyncIOMotorClient(settings.MONGODB_URL)
        self.db = self.client[settings.DATABASE_NAME]

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        self.client.close()

    async def check_connection(self) -> bool:
        """Test MongoDB connection with detailed feedback"""
        try:
            await self.client.admin.command('ping')
            server_info = await self.client.server_info()
            console.print("✅ MongoDB Connection Successful", style="green")
            console.print(f"   Server Version: {server_info.get('version', 'Unknown')}")
            console.print(f"   Connection URL: {settings.MONGODB_URL}")
            return True
        except Exception as e:
            console.print(f"❌ MongoDB Connection Failed: {e}", style="red")
            console.print("\n💡 Troubleshooting:")
            console.print("   • Ensure MongoDB service is running")
            console.print("   • Check connection URL in .env file")
            console.print("   • Verify network connectivity")
            return False

    async def create_collections(self) -> bool:
        """Create required collections with proper structure"""
        collections_config = {
            'users': [
                ("username", 1),
                ("email", 1)
            ],
            'firewall_rules': [
                ("rule_name", 1),
                ("priority", 1),
                ("enabled", 1)
            ],
            'firewall_groups': [
                ("group_name", 1)
            ],
            'network_interfaces': [
                ("interface_name", 1)
            ],
            'static_routes': [
                ("destination", 1),
                ("enabled", 1)
            ],
            'blocked_domains': [
                ("domain", 1),
                ("created_at", -1)
            ],
            'system_logs': [
                ("timestamp", -1),
                ("level", 1),
                ("source", 1)
            ],
            'blocked_packets': [
                ("timestamp", -1),
                ("source_ip", 1)
            ],
            'security_alerts': [
                ("timestamp", -1),
                ("severity", 1),
                ("acknowledged", 1)
            ],
            'nat_config': [],
            'dns_proxy_config': [],
            'system_config': []
        }

        try:
            existing_collections = set(await self.db.list_collection_names())

            with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    console=console
            ) as progress:
                task = progress.add_task("Creating collections...", total=len(collections_config))

                for collection_name, indexes in collections_config.items():
                    progress.update(task, description=f"Setting up {collection_name}")

                    # Create collection if it doesn't exist
                    if collection_name not in existing_collections:
                        await self.db.create_collection(collection_name)

                    # Create indexes
                    for index_spec in indexes:
                        try:
                            if collection_name == 'users':
                                if index_spec[0] == "username":
                                    await self.db[collection_name].create_index([index_spec], unique=True)
                                elif index_spec[0] == "email":
                                    await self.db[collection_name].create_index([index_spec], unique=True, sparse=True)
                                else:
                                    await self.db[collection_name].create_index([index_spec])
                            elif collection_name == 'firewall_rules' and index_spec[0] == "rule_name":
                                await self.db[collection_name].create_index([index_spec], unique=True)
                            elif collection_name == 'firewall_groups' and index_spec[0] == "group_name":
                                await self.db[collection_name].create_index([index_spec], unique=True)
                            elif collection_name == 'network_interfaces' and index_spec[0] == "interface_name":
                                await self.db[collection_name].create_index([index_spec], unique=True)
                            elif collection_name == 'blocked_domains' and index_spec[0] == "domain":
                                await self.db[collection_name].create_index([index_spec], unique=True)
                            else:
                                await self.db[collection_name].create_index([index_spec])
                        except Exception as e:
                            if "already exists" not in str(e).lower():
                                console.print(f"⚠️  Index creation warning for {collection_name}: {e}")

                    progress.advance(task)

            console.print("✅ Collections and indexes created successfully", style="green")
            return True
        except Exception as e:
            console.print(f"❌ Collection creation failed: {e}", style="red")
            return False

    async def create_admin_user(self) -> bool:
        """Create admin user with secure password hashing"""
        try:
            # Check if admin already exists
            existing_admin = await self.db.users.find_one({"username": "admin"})
            if existing_admin:
                console.print("✅ Admin user already exists", style="yellow")
                return True

            # Create admin user
            hashed_password = pwd_context.hash("admin123")
            admin_user = {
                "username": "admin",
                "email": "admin@localhost",
                "hashed_password": hashed_password,
                "role": "admin",
                "is_active": True,
                "created_at": datetime.utcnow(),
                "last_login": None,
                "failed_login_attempts": 0,
                "settings": {
                    "theme": "dark",
                    "language": "en",
                    "timezone": "UTC"
                },
                "permissions": []
            }

            result = await self.db.users.insert_one(admin_user)

            # Create credentials panel
            credentials_table = Table(title="Admin Credentials")
            credentials_table.add_column("Field", style="cyan")
            credentials_table.add_column("Value", style="green")
            credentials_table.add_row("Username", "admin")
            credentials_table.add_row("Password", "admin123")
            credentials_table.add_row("Role", "admin")
            credentials_table.add_row("Database ID", str(result.inserted_id))

            console.print(Panel(credentials_table, title="✅ Admin User Created"))
            return True
        except Exception as e:
            console.print(f"❌ Admin user creation failed: {e}", style="red")
            return False

    async def create_default_configs(self) -> bool:
        """Create default system configurations"""
        try:
            configs = [
                {
                    "collection": "system_config",
                    "document": {
                        "_id": "main",
                        "project_name": "KOBI Firewall",
                        "version": "2.0.0",
                        "timezone": "UTC",
                        "auto_backup": True,
                        "log_retention_days": 30,
                        "created_at": datetime.utcnow()
                    }
                },
                {
                    "collection": "nat_config",
                    "document": {
                        "_id": "main",
                        "enabled": False,
                        "wan_interface": "",
                        "lan_interface": "",
                        "created_at": datetime.utcnow()
                    }
                },
                {
                    "collection": "dns_proxy_config",
                    "document": {
                        "_id": "main",
                        "enabled": False,
                        "listen_port": 53,
                        "upstream_servers": ["8.8.8.8", "8.8.4.4"],
                        "block_malware": True,
                        "block_ads": False,
                        "created_at": datetime.utcnow()
                    }
                }
            ]

            for config in configs:
                await self.db[config["collection"]].update_one(
                    {"_id": config["document"]["_id"]},
                    {"$setOnInsert": config["document"]},
                    upsert=True
                )

            console.print("✅ Default configurations created", style="green")
            return True
        except Exception as e:
            console.print(f"❌ Default config creation failed: {e}", style="red")
            return False

    async def create_sample_data(self) -> bool:
        """Create sample firewall rules and groups"""
        try:
            # Sample firewall group
            sample_group = {
                "group_name": "Web Services",
                "description": "HTTP/HTTPS web services rules",
                "created_at": datetime.utcnow()
            }
            await self.db.firewall_groups.update_one(
                {"group_name": "Web Services"},
                {"$setOnInsert": sample_group},
                upsert=True
            )

            # Sample firewall rule
            sample_rule = {
                "rule_name": "Allow_HTTP_HTTPS",
                "source_ips": ["0.0.0.0/0"],
                "destination_ports": ["80", "443"],
                "protocol": "TCP",
                "action": "ALLOW",
                "direction": "IN",
                "enabled": True,
                "priority": 100,
                "description": "Allow HTTP and HTTPS traffic",
                "created_at": datetime.utcnow()
            }
            await self.db.firewall_rules.update_one(
                {"rule_name": "Allow_HTTP_HTTPS"},
                {"$setOnInsert": sample_rule},
                upsert=True
            )

            console.print("✅ Sample data created", style="green")
            return True
        except Exception as e:
            console.print(f"⚠️  Sample data creation failed: {e}", style="yellow")
            return False


async def main():
    """Main initialization function"""
    console.print(Panel.fit(
        "[bold blue]KOBI Firewall[/bold blue]\n"
        "[green]Enterprise Security Solution[/green]\n"
        "[dim]Database Initialization & Setup[/dim]",
        border_style="blue"
    ))

    try:
        async with DatabaseInitializer() as db_init:
            steps = [
                ("Connection Test", db_init.check_connection),
                ("Collections Setup", db_init.create_collections),
                ("Admin User Creation", db_init.create_admin_user),
                ("Default Configs", db_init.create_default_configs),
                ("Sample Data", db_init.create_sample_data)
            ]

            success_count = 0
            for step_name, step_func in steps:
                console.print(f"\n🔄 {step_name}...")
                if await step_func():
                    success_count += 1
                else:
                    console.print(f"❌ {step_name} failed", style="red")
                    if step_name in ["Connection Test", "Collections Setup", "Admin User Creation"]:
                        console.print("⚠️  Critical step failed, stopping initialization", style="red")
                        return 1

            # Final summary
            console.print(f"\n{'=' * 60}")
            console.print(f"✅ Initialization Complete! ({success_count}/{len(steps)} steps successful)")

            # Access information panel
            access_info = Table(title="🌐 Access Information")
            access_info.add_column("Service", style="cyan")
            access_info.add_column("URL", style="green")
            access_info.add_row("Web Interface", "http://localhost:3001")
            access_info.add_row("API Documentation", "http://localhost:8000/docs")
            access_info.add_row("Admin Panel", "http://localhost:8000/admin")

            console.print(Panel(access_info))
            console.print("\n🚀 Ready to start the application!")
            console.print("   Backend: uvicorn app.main:app --reload")
            console.print("   Frontend: npm start (port 3001)")
            return 0

    except KeyboardInterrupt:
        console.print("\n⚠️  Initialization cancelled by user", style="yellow")
        return 1
    except Exception as e:
        console.print(f"\n❌ Unexpected error: {e}", style="red")
        return 1


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)


================================================
File: nodemon.json
================================================
{
  "watch": ["./"],
  "ext": "js,json",
  "ignore": ["node_modules/", "logs/"],
  "exec": "node server.js",
  "env": {
    "NODE_ENV": "development"
  }
}


================================================
File: package.json
================================================
{
  "name": "kobi-firewall-backend",
  "version": "1.0.0",
  "description": "NetGate Firewall Management System Backend",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": ["firewall", "security", "management"],
  "author": "NetGate Team",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^7.6.3",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "express-rate-limit": "^7.1.5",
    "dotenv": "^16.3.1",
    "validator": "^13.11.0",
    "express-validator": "^7.0.1",
    "winston": "^3.11.0",
    "compression": "^1.7.4",
    "node-cron": "^3.0.3"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}


================================================
File: pyproject.toml
================================================
[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "kobi-firewall-backend"
version = "2.0.0"
description = "Enterprise-grade firewall management system - Backend API"
readme = "README.md"
license = {file = "LICENSE"}
authors = [
    {name = "KOBI Firewall Team", email = "team@kobifirewall.com"}
]
maintainers = [
    {name = "KOBI Firewall Team", email = "team@kobifirewall.com"}
]
keywords = [
    "firewall",
    "security",
    "network",
    "fastapi",
    "enterprise",
    "cybersecurity"
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: System Administrators",
    "Intended Audience :: Information Technology",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Topic :: System :: Networking :: Firewalls",
    "Topic :: System :: Systems Administration",
    "Topic :: Security",
    "Framework :: FastAPI",
    "Environment :: Web Environment",
    "Typing :: Typed"
]
requires-python = ">=3.11"
dependencies = [
    "fastapi>=0.104.1,<0.105.0",
    "uvicorn[standard]>=0.24.0,<0.25.0",
    "pydantic>=2.5.0,<3.0.0",
    "pydantic-settings>=2.1.0,<3.0.0",
    "motor>=3.3.2,<4.0.0",
    "pymongo>=4.6.0,<5.0.0",
    "python-jose[cryptography]>=3.3.0,<4.0.0",
    "passlib[bcrypt]>=1.7.4,<2.0.0",
    "python-multipart>=0.0.6,<1.0.0",
    "python-dotenv>=1.0.0,<2.0.0",
    "psutil>=5.9.6,<6.0.0",
    "requests>=2.31.0,<3.0.0",
    "dnspython>=2.4.2,<3.0.0",
    "structlog>=23.2.0,<24.0.0",
    "rich>=13.7.0,<14.0.0",
    "slowapi>=0.1.9,<1.0.0"
]

[project.optional-dependencies]
dev = [
    "pytest>=7.4.3,<8.0.0",
    "pytest-asyncio>=0.21.1,<1.0.0",
    "httpx>=0.25.2,<1.0.0",
    "pytest-cov>=4.1.0,<5.0.0",
    "pytest-mock>=3.12.0,<4.0.0",
    "factory-boy>=3.3.0,<4.0.0",
    "faker>=20.1.0,<21.0.0"
]
lint = [
    "black>=23.11.0,<24.0.0",
    "isort>=5.12.0,<6.0.0",
    "flake8>=6.1.0,<7.0.0",
    "mypy>=1.7.0,<2.0.0",
    "bandit[toml]>=1.7.5,<2.0.0",
    "safety>=2.3.5,<3.0.0"
]
docs = [
    "mkdocs>=1.5.3,<2.0.0",
    "mkdocs-material>=9.4.8,<10.0.0",
    "mkdocstrings[python]>=0.24.0,<1.0.0"
]
monitoring = [
    "prometheus-client>=0.19.0,<1.0.0",
    "sentry-sdk[fastapi]>=1.38.0,<2.0.0",
    "opentelemetry-api>=1.21.0,<2.0.0",
    "opentelemetry-sdk>=1.21.0,<2.0.0"
]
security = [
    "cryptography>=41.0.7,<42.0.0",
    "pycryptodome>=3.19.0,<4.0.0"
]
network = [
    "scapy>=2.5.0,<3.0.0",
    "netaddr>=0.10.1,<1.0.0",
    "ipaddress>=1.0.23; python_version<'3.3'"
]
all = [
    "kobi-firewall-backend[dev,lint,docs,monitoring,security,network]"
]

[project.urls]
Homepage = "https://github.com/your-org/kobi-firewall"
Documentation = "https://docs.kobifirewall.com"
Repository = "https://github.com/your-org/kobi-firewall.git"
"Bug Tracker" = "https://github.com/your-org/kobi-firewall/issues"
Changelog = "https://github.com/your-org/kobi-firewall/blob/main/CHANGELOG.md"

[project.scripts]
kobi-firewall = "app.cli:main"
kobi-init-db = "create_admin:main"

[tool.setuptools.packages.find]
where = ["."]
include = ["app*"]
exclude = ["tests*", "docs*"]

[tool.setuptools.package-data]
"*" = ["*.yaml", "*.yml", "*.json", "*.toml"]

# Black - Code formatting
[tool.black]
line-length = 88
target-version = ['py311']
include = '\.pyi?$'
extend-exclude = '''
/(
  # directories
  \.eggs
  | \.git
  | \.hg
  | \.mypy_cache
  | \.tox
  | \.venv
  | build
  | dist
  | migrations
)/
'''

# isort - Import sorting
[tool.isort]
profile = "black"
multi_line_output = 3
include_trailing_comma = true
force_grid_wrap = 0
use_parentheses = true
ensure_newline_before_comments = true
line_length = 88
src_paths = ["app", "tests"]
skip_glob = ["*/migrations/*"]

# Flake8 - Linting
[tool.flake8]
max-line-length = 88
exclude = [
    ".git",
    "__pycache__",
    "build",
    "dist",
    ".venv",
    "venv",
    ".mypy_cache",
    ".pytest_cache"
]
ignore = [
    "E203",  # whitespace before ':'
    "E501",  # line too long (handled by black)
    "W503",  # line break before binary operator
    "F401",  # imported but unused (handled by mypy)
]
per-file-ignores = [
    "__init__.py:F401",
    "tests/*:S101,S106",  # allow assert and hardcoded passwords in tests
]

# MyPy - Type checking
[tool.mypy]
python_version = "3.11"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true
show_error_codes = true
show_column_numbers = true
show_error_context = true
pretty = true

[[tool.mypy.overrides]]
module = [
    "motor.*",
    "pymongo.*",
    "scapy.*",
    "dnspython.*",
    "slowapi.*"
]
ignore_missing_imports = true

# Pytest - Testing
[tool.pytest.ini_options]
minversion = "7.0"
addopts = [
    "--strict-markers",
    "--strict-config",
    "--verbose",
    "--tb=short",
    "--cov=app",
    "--cov-report=term-missing",
    "--cov-report=html:htmlcov",
    "--cov-report=xml",
    "--cov-fail-under=80",
    "--asyncio-mode=auto"
]
testpaths = ["tests"]
python_files = ["test_*.py", "*_test.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
markers = [
    "unit: Unit tests",
    "integration: Integration tests",
    "e2e: End-to-end tests",
    "slow: Slow running tests",
    "network: Tests requiring network access",
    "database: Tests requiring database",
    "windows: Windows-specific tests",
    "linux: Linux-specific tests"
]
filterwarnings = [
    "error",
    "ignore::UserWarning",
    "ignore::DeprecationWarning",
    "ignore::PendingDeprecationWarning"
]

# Coverage.py
[tool.coverage.run]
source = ["app"]
omit = [
    "tests/*",
    "*/migrations/*",
    "*/venv/*",
    "*/__pycache__/*",
    "*/conftest.py"
]
branch = true

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "if self.debug:",
    "if settings.DEBUG",
    "raise AssertionError",
    "raise NotImplementedError",
    "if 0:",
    "if __name__ == .__main__.:",
    "class .*\bProtocol\):",
    "@(abc\.)?abstractmethod"
]
show_missing = true
skip_covered = false
precision = 2

[tool.coverage.html]
directory = "htmlcov"

[tool.coverage.xml]
output = "coverage.xml"

# Bandit - Security linting
[tool.bandit]
exclude_dirs = ["tests", "venv", ".venv"]
tests = ["B201", "B301"]
skips = ["B101", "B601"]

[tool.bandit.assert_used]
skips = ["*_test.py", "**/test_*.py"]

# Ruff - Fast Python linter (alternative to flake8)
[tool.ruff]
target-version = "py311"
line-length = 88
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # pyflakes
    "I",  # isort
    "B",  # flake8-bugbear
    "C4", # flake8-comprehensions
    "UP", # pyupgrade
    "ARG001", # unused-function-argument
    "SIM", # flake8-simplify
    "TC",  # flake8-type-checking
    "PTH", # flake8-use-pathlib
]
ignore = [
    "E501", # line-too-long, handled by black
    "B008", # do not perform function calls in argument defaults
    "B905", # zip without an explicit strict parameter
    "C901", # too complex
]

[tool.ruff.per-file-ignores]
"__init__.py" = ["F401"]
"tests/**/*" = ["PLR2004", "S101", "TID252"]

[tool.ruff.isort]
known-first-party = ["app"]

[tool.ruff.flake8-tidy-imports]
ban-relative-imports = "all"

[tool.ruff.pyupgrade]
keep-percent-format = true

# Docstring formatting
[tool.docformatter]
recursive = true
wrap-summaries = 88
wrap-descriptions = 88
make-summary-multi-line = false
close-quotes-on-newline = true
force-wrap = false
tab-width = 4

# Import sorting for notebooks
[tool.nbqa.config]
isort = "pyproject.toml"
black = "pyproject.toml"
flake8 = "pyproject.toml"

[tool.nbqa.mutate]
isort = 1
black = 1

[tool.nbqa.shell]
flake8 = "flake8 --extend-ignore=E402,F401"

# Security scanning configuration
[tool.safety]
ignore = [
    # Add CVE IDs to ignore here if needed
]
output = "json"
full-report = true

# Performance profiling
[tool.py-spy]
duration = 30
rate = 100
subprocesses = true


================================================
File: qc
================================================
MongoDB



================================================
File: query
================================================
MongoDB



================================================
File: requirements.txt
================================================
fastapi==0.104.1
uvicorn[standard]==0.24.0
motor==3.3.2
pymongo==4.6.0
pydantic==2.5.0
pydantic-settings==2.1.0
PyJWT==2.8.0
python-jose[cryptography]==3.3.0
python-multipart==0.0.6
passlib[bcrypt]==1.7.4
reportlab==4.0.7


================================================
File: run_server.py
================================================
# run_server.py - GÜNCELLENMIŞ FULL KOD
import sys
import os
import traceback
import uvicorn
from pathlib import Path

# Add the backend directory to Python path
backend_dir = Path(__file__).parent
sys.path.insert(0, str(backend_dir))

print("=== KOBI Firewall Backend Startup ===")

try:
    print("1. Creating FastAPI app...")
    from fastapi import FastAPI, HTTPException, status
    from fastapi.middleware.cors import CORSMiddleware
    from pydantic import BaseModel
    from datetime import datetime

    app = FastAPI(
        title="KOBI Firewall",
        description="Enterprise Security Solution",
        version="2.0.0"
    )

    # CORS
    app.add_middleware(
        CORSMiddleware,
        allow_origins=[
            "http://localhost:3000",
            "http://127.0.0.1:3000",
            "http://localhost:3001",
            "http://127.0.0.1:3001"
        ],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )


    # Models
    class LoginRequest(BaseModel):
        username: str
        password: str
        remember_me: bool = False
        rememberMe: bool = False


    class UserResponse(BaseModel):
        id: str
        username: str
        email: str
        role: str
        is_active: bool = True


    class TokenResponse(BaseModel):
        success: bool = True
        access_token: str
        token_type: str = "bearer"
        expires_in: int = 28800
        user: UserResponse


    # Basic endpoints
    @app.get("/")
    def read_root():
        return {
            "service": "KOBI Firewall",
            "status": "running",
            "version": "2.0.0",
            "timestamp": datetime.utcnow().isoformat(),
            "docs_url": "/docs",
            "health_url": "/health"
        }


    @app.get("/health")
    def health_check():
        return {
            "status": "healthy",
            "service": "KOBI Firewall",
            "message": "Backend is running successfully on port 8000",
            "timestamp": datetime.utcnow().isoformat()
        }


    # AUTH ENDPOINTS
    @app.post("/api/auth/login", response_model=TokenResponse)
    def login_user(credentials: LoginRequest):
        print(f"🔐 Login attempt: {credentials.username}")
        remember_me = credentials.remember_me or credentials.rememberMe

        if credentials.username == "admin" and credentials.password == "admin123":
            user_data = UserResponse(
                id="admin-user-id",
                username="admin",
                email="admin@localhost",
                role="admin",
                is_active=True
            )
            result = TokenResponse(
                success=True,
                access_token="test-token-admin-123456789",
                token_type="bearer",
                expires_in=28800,
                user=user_data
            )
            print(f"✅ Login successful for: {credentials.username}")
            return result
        else:
            print(f"❌ Login failed for: {credentials.username}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid username or password"
            )


    @app.post("/api/v1/auth/login", response_model=TokenResponse)
    def login_user_v1(credentials: LoginRequest):
        return login_user(credentials)


    @app.get("/api/auth/me")
    def get_current_user():
        return {
            "success": True,
            "id": "admin-user-id",
            "username": "admin",
            "email": "admin@localhost",
            "role": "admin",
            "is_active": True,
            "created_at": datetime.utcnow().isoformat(),
            "last_login": datetime.utcnow().isoformat()
        }


    @app.get("/api/v1/auth/me")
    def get_current_user_v1():
        return get_current_user()


    @app.get("/api/auth/verify")
    def verify_token():
        return {
            "success": True,
            "user": {
                "id": "admin-user-id",
                "username": "admin",
                "email": "admin@localhost",
                "role": "admin",
                "is_active": True
            }
        }


    @app.get("/api/v1/auth/verify")
    def verify_token_v1():
        return verify_token()


    @app.post("/api/auth/logout")
    def logout():
        return {"success": True, "message": "Logged out successfully"}


    @app.post("/api/v1/auth/logout")
    def logout_v1():
        return logout()


    # DASHBOARD ENDPOINTS
    @app.get("/api/dashboard/stats")
    def get_dashboard_stats():
        return {
            "success": True,
            "data": {
                "status": "Aktif",
                "connectedDevices": 5,
                "activeRules": 12,
                "totalConnections": 1250,
                "blocked": 125,
                "threats": 15,
                "lastUpdate": datetime.utcnow().isoformat(),
                "securityLevel": 87.5,
                "monthlyGrowth": 12.5,
                "uptime": 86400,
                "systemHealth": {
                    "cpu": {"percentage": 45.2},
                    "memory": {"percentage": 67.8, "total": 8192, "used": 5543},
                    "dataCollection": {"isCollecting": True}
                },
                "totalActivities": 5420,
                "oldestActivity": "2024-01-01T00:00:00Z",
                "newestActivity": datetime.utcnow().isoformat()
            }
        }


    @app.get("/api/v1/dashboard/stats")
    def get_dashboard_stats_v1():
        return get_dashboard_stats()


    @app.get("/api/dashboard/chart-data")
    def get_chart_data(period: str = "24h"):
        import random
        data = []
        if period == "24h":
            for i in range(24):
                hour = f"{i:02d}:00"
                total = random.randint(50, 200)
                blocked = random.randint(5, 25)
                data.append({
                    "time": hour,
                    "totalConnections": total,
                    "blockedConnections": blocked,
                    "allowedConnections": total - blocked,
                    "threats": random.randint(0, 5)
                })
        return {
            "success": True,
            "data": data,
            "meta": {
                "period": period,
                "dataPoints": len(data),
                "dataSource": "simulation"
            }
        }


    @app.get("/api/v1/dashboard/chart-data")
    def get_chart_data_v1(period: str = "24h"):
        return get_chart_data(period)


    @app.get("/api/dashboard/recent-activity")
    def get_recent_activity(limit: int = 10):
        import random
        activities = []
        for i in range(limit):
            activity_type = random.choice(["blocked", "allowed", "warning"])
            domain = random.choice([
                "google.com", "facebook.com", "malicious-site.com",
                "github.com", "suspicious-domain.net"
            ])
            activities.append({
                "id": f"activity_{i}",
                "type": activity_type,
                "domain": domain,
                "ip": f"192.168.1.{random.randint(10, 50)}",
                "port": random.choice([80, 443, 22, 3389]),
                "timestamp": datetime.utcnow().isoformat(),
                "threat": {
                    "detected": activity_type == "blocked",
                    "type": "malware" if activity_type == "blocked" else "none",
                    "severity": "high" if activity_type == "blocked" else "low"
                }
            })
        return {
            "success": True,
            "data": activities,
            "meta": {
                "total": 1000,
                "dataSource": "simulation"
            }
        }


    @app.get("/api/v1/dashboard/recent-activity")
    def get_recent_activity_v1(limit: int = 10):
        return get_recent_activity(limit)


    @app.get("/api/dashboard/connected-devices")
    def get_connected_devices():
        devices = [
            {"ip": "192.168.1.10", "mac": "00:11:22:33:44:55", "hostname": "admin-laptop", "status": "active"},
            {"ip": "192.168.1.15", "mac": "00:11:22:33:44:56", "hostname": "server-001", "status": "active"},
            {"ip": "192.168.1.20", "mac": "00:11:22:33:44:57", "hostname": "workstation-02", "status": "active"},
            {"ip": "192.168.1.25", "mac": "00:11:22:33:44:58", "hostname": "mobile-device", "status": "active"},
            {"ip": "10.0.0.5", "mac": "00:11:22:33:44:59", "hostname": "printer-hp", "status": "active"}
        ]
        return {
            "success": True,
            "data": devices
        }


    @app.get("/api/v1/dashboard/connected-devices")
    def get_connected_devices_v1():
        return get_connected_devices()


    @app.get("/api/dashboard/data-status")
    def get_data_status():
        return {
            "success": True,
            "data": {
                "persistence": {
                    "enabled": True,
                    "dataCollection": True,
                    "totalActivities": 5420,
                    "systemUptime": 86400
                }
            }
        }


    @app.get("/api/v1/dashboard/data-status")
    def get_data_status_v1():
        return get_data_status()


    @app.post("/api/dashboard/simulate-activity")
    def simulate_activity():
        return {
            "success": True,
            "message": "Demo aktivite oluşturuldu"
        }


    @app.post("/api/v1/dashboard/simulate-activity")
    def simulate_activity_v1():
        return simulate_activity()


    # SYSTEM/UPDATES ENDPOINTS - YENİ EKLENEN
    @app.get("/api/v1/system/updates")
    def get_system_updates():
        return {
            "success": True,
            "data": {
                "currentVersion": "2.1.0",
                "latestVersion": "2.1.2",
                "status": "Güncel",
                "lastCheck": datetime.utcnow().strftime("%Y-%m-%d %H:%M"),
                "checkMethod": "Otomatik",
                "pendingUpdates": 2,
                "updateStatus": "Yükleme bekleniyor",
                "availableUpdates": [
                    {
                        "id": "update_1",
                        "_id": "update_1",
                        "name": "NetGate Firewall 2.1.2 Patch",
                        "version": "2.1.2",
                        "priority": "Yüksek Öncelikli",
                        "update_type": "Kritik Güvenlik Güncellemesi",
                        "release_date": datetime.utcnow().isoformat(),
                        "date": "2025-06-19",
                        "size": "45 MB",
                        "location": "/system/updates",
                        "status": "Bekliyor",
                        "changes": [
                            "Yeni nesil güvenlik açığı kapatıldı",
                            "Firewall kuralları işleme hızı artırıldı",
                            "Şüpheli kullanıcı algoritması geliştirildi"
                        ]
                    },
                    {
                        "id": "update_2",
                        "_id": "update_2",
                        "name": "NetGate Firewall 2.1.1",
                        "version": "2.1.1",
                        "priority": "Orta Öncelikli",
                        "update_type": "Hata düzeltmeleri ve iyileştirmeler",
                        "release_date": datetime.utcnow().isoformat(),
                        "date": "2025-06-12",
                        "size": "23 MB",
                        "location": "/system/updates",
                        "status": "Bekliyor",
                        "changes": [
                            "VPN bağlantılarında karşı sorun düzeltildi",
                            "Log görüntüleme performansı iyileştirildi",
                            "Küçük arayüz hataları giderildi"
                        ]
                    }
                ],
                "updateHistory": [
                    {
                        "version": "NetGate Firewall 2.1.0",
                        "update_type": "Ana sürüm",
                        "install_date": "2025-06-10",
                        "date": "2025-06-10",
                        "status": "Başarılı"
                    },
                    {
                        "version": "NetGate Firewall 2.0.8",
                        "update_type": "Güvenlik güncellemesi",
                        "install_date": "2025-05-28",
                        "date": "2025-05-28",
                        "status": "Başarılı"
                    },
                    {
                        "version": "NetGate Firewall 2.0.7",
                        "update_type": "Hata düzeltmesi",
                        "install_date": "2025-05-15",
                        "date": "2025-05-15",
                        "status": "Başarılı"
                    }
                ],
                "updateSettings": {
                    "autoUpdate": True,
                    "checkFrequency": "daily",
                    "autoInstallTime": "02:00"
                },
                "systemInfo": {
                    "product": "NetGate Firewall",
                    "currentVersion": "2.1.0",
                    "latestVersion": "2.1.2",
                    "buildDate": "2025.06.19",
                    "license": "Pro"
                }
            }
        }


    @app.post("/api/v1/system/updates/check")
    def check_updates():
        return {
            "success": True,
            "message": "Güncelleme kontrolü tamamlandı",
            "details": {"checked_at": datetime.utcnow().isoformat()}
        }


    @app.post("/api/v1/system/updates/{update_id}/install")
    def install_update(update_id: str):
        return {
            "success": True,
            "message": "Güncelleme yüklemesi başlatıldı",
            "details": {"update_id": update_id}
        }


    @app.patch("/api/v1/system/updates/settings")
    def update_settings(settings: dict):
        return {
            "success": True,
            "message": "Güncelleme ayarları kaydedildi",
            "details": settings
        }


    @app.get("/api/v1/system/updates/history")
    def get_update_history(limit: int = 20):
        return {
            "success": True,
            "data": [
                {
                    "id": "history_1",
                    "version": "NetGate Firewall 2.1.0",
                    "update_type": "System Update",
                    "install_date": "2025-06-10",
                    "status": "Başarılı"
                }
            ],
            "meta": {"total": 1, "limit": limit}
        }


    # FIREWALL ENDPOINTS
    @app.get("/api/firewall/rules/stats")
    def get_firewall_stats():
        return {
            "success": True,
            "data": {
                "total_rules": 12,
                "enabled_rules": 8,
                "allow_rules": 5,
                "deny_rules": 7,
                "total_hits": 1250
            }
        }


    @app.get("/api/v1/firewall/rules/stats")
    def get_firewall_stats_v1():
        return get_firewall_stats()


    @app.post("/api/firewall/initialize-rules")
    def initialize_rules():
        return {
            "success": True,
            "message": "Firewall kuralları başlatıldı"
        }


    @app.post("/api/v1/firewall/initialize-rules")
    def initialize_rules_v1():
        return initialize_rules()


    print("2. Starting server...")
    print("🚀 Server starting on http://127.0.0.1:8000")
    print("📋 API docs: http://127.0.0.1:8000/docs")
    print("❤️ Health check: http://127.0.0.1:8000/health")
    print("🔐 Test login: admin / admin123")
    print("🔄 Updates endpoint: http://127.0.0.1:8000/api/v1/system/updates")
    print("")
    print("Ready to accept connections!")

    # Start server
    uvicorn.run(
        app,
        host="127.0.0.1",
        port=8000,
        log_level="info",
        access_log=True
    )

except Exception as e:
    print(f"\n❌ FATAL ERROR: {e}")
    print(f"Error type: {type(e).__name__}")
    traceback.print_exc()


================================================
File: server.js
================================================
const express = require('express');
const cors = require('cors');
const path = require('path');
const rateLimit = require('express-rate-limit');

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use('/api/', limiter);

// Serve static files from React build
app.use(express.static(path.join(__dirname, '../frontend/build')));

// Routes
app.use('/api/auth', require('./routes/auth'));
app.use('/api/dashboard', require('./routes/dashboard'));
app.use('/api/logs', require('./routes/logs'));
app.use('/api/security-rules', require('./routes/securityRules'));
app.use('/api/rule-groups', require('./routes/ruleGroups'));
app.use('/api/interfaces', require('./routes/interfaces'));
app.use('/api/nat', require('./routes/nat'));
app.use('/api/routes', require('./routes/routes'));
app.use('/api/dns', require('./routes/dns'));
app.use('/api/settings', require('./routes/settings'));
app.use('/api/system', require('./routes/system'));
app.use('/api/security', require('./routes/security'));
app.use('/api/reports', require('./routes/reports'));
app.use('/api/updates', require('./routes/updates'));

// Catch all handler: send back React's index.html file
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '../frontend/build/index.html'));
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Sunucu hatasÄ±' });
});

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});


================================================
File: simple_test.py
================================================
# simple_test.py
from fastapi import FastAPI
import uvicorn

app = FastAPI(title="Test Server")

@app.get("/")
def read_root():
    return {"message": "Test server is working!"}

@app.get("/health")
def health_check():
    return {"status": "healthy", "message": "Simple test server"}

if __name__ == "__main__":
    print("Starting simple test server...")
    uvicorn.run(app, host="127.0.0.1", port=8000)


================================================
File: .env.backup
================================================
# Server Configuration
NODE_ENV=development
PORT=5000
HOST=localhost

# Database Configuration
MONGODB_URI=mongodb://localhost:27017/netgate-firewall
DB_NAME=netgate-firewall

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_EXPIRES_IN=24h
JWT_REFRESH_SECRET=your-refresh-secret-key
JWT_REFRESH_EXPIRES_IN=7d

# CORS Configuration
FRONTEND_URL=http://localhost:3000
ALLOWED_ORIGINS=http://localhost:3000,http://127.0.0.1:3000

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# Security
BCRYPT_SALT_ROUNDS=12

# Logging
LOG_LEVEL=info
LOG_FILE=logs/app.log

# Default Admin User
DEFAULT_ADMIN_USERNAME=admin
DEFAULT_ADMIN_PASSWORD=admin123
DEFAULT_ADMIN_EMAIL=admin@netgate.local


================================================
File: app/__init__.py
================================================
"""
KOBI Firewall System
Advanced Network Security Management Platform
"""

__version__ = "2.0.0"
__author__ = "KOBI Firewall Team"
__description__ = "Advanced Network Security Management Platform"


================================================
File: app/config.py
================================================
import os
from functools import lru_cache
from pydantic_settings import BaseSettings
from typing import Optional, List


class Settings(BaseSettings):
    """Application settings"""

    # App Configuration
    APP_NAME: str = "KOBI Firewall"
    APP_VERSION: str = "2.0.0"
    DEBUG: bool = False
    NODE_ENV: str = "development"

    # Database Configuration
    MONGODB_URL: str = "mongodb://localhost:27017"
    MONGODB_URI: str = "mongodb://localhost:27017/kobi_firewall_db"  # Eski format iÃ§in
    DATABASE_NAME: str = "kobi_firewall_db"
    DB_NAME: str = "kobi_firewall_db"  # Eski format iÃ§in

    # Security Configuration
    SECRET_KEY: str = "kobi-firewall-secret-key-change-in-production"
    JWT_SECRET: str = "your-super-secret-jwt-key-change-this-in-production"  # Eski format iÃ§in
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 1440  # 24 hours
    JWT_EXPIRES_IN: str = "24h"  # Eski format iÃ§in
    JWT_REFRESH_SECRET: str = "your-refresh-secret-key"  # Eski format iÃ§in
    JWT_REFRESH_EXPIRES_IN: str = "7d"  # Eski format iÃ§in
    ALGORITHM: str = "HS256"

    # Server Configuration
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    RELOAD: bool = True
    FRONTEND_URL: str = "http://localhost:3000"

    # CORS Configuration
    CORS_ORIGINS: List[str] = [
        "http://localhost:3000",
        "http://127.0.0.1:3000",
        "http://localhost:3001",
        "http://127.0.0.1:3001",
        "http://localhost:5173",
        "http://127.0.0.1:5173"
    ]
    ALLOWED_ORIGINS: str = "http://localhost:3000,http://127.0.0.1:3000"  # Eski format iÃ§in

    # Logging Configuration
    LOG_LEVEL: str = "INFO"
    LOG_FILE: str = "kobi_firewall.log"

    # Feature Flags
    ENABLE_SWAGGER: bool = True
    ENABLE_REDOC: bool = True

    # File Upload Configuration
    MAX_FILE_SIZE: int = 10 * 1024 * 1024  # 10MB
    UPLOAD_DIR: str = "uploads"

    # Backup Configuration
    BACKUP_DIR: str = "backups"
    BACKUP_RETENTION_DAYS: int = 30

    # Firewall Configuration
    DEFAULT_POLICY: str = "DROP"
    MAX_RULES: int = 1000

    # Network Configuration
    NETWORK_SCAN_TIMEOUT: int = 30
    PING_TIMEOUT: int = 5

    # Rate Limiting
    RATE_LIMIT_REQUESTS: int = 100
    RATE_LIMIT_MAX_REQUESTS: str = "100"  # Eski format iÃ§in
    RATE_LIMIT_WINDOW: int = 60  # seconds
    RATE_LIMIT_WINDOW_MS: str = "900000"  # Eski format iÃ§in

    # Security
    BCRYPT_SALT_ROUNDS: str = "12"  # Eski format iÃ§in

    # Default Admin Configuration
    DEFAULT_ADMIN_USERNAME: str = "admin"
    DEFAULT_ADMIN_PASSWORD: str = "admin123"
    DEFAULT_ADMIN_EMAIL: str = "admin@netgate.local"

    # Email Configuration (if needed)
    SMTP_HOST: Optional[str] = None
    SMTP_PORT: Optional[int] = None
    SMTP_USER: Optional[str] = None
    SMTP_PASSWORD: Optional[str] = None

    model_config = {
        "env_file": ".env",
        "env_file_encoding": "utf-8",
        "case_sensitive": True,
        "extra": "ignore"  # Bu satÄ±r Ã¶nemli - extra alanlarÄ± gÃ¶z ardÄ± eder
    }


@lru_cache()
def get_settings() -> Settings:
    """Get cached settings instance"""
    return Settings()


# Environment-specific configurations
def get_development_settings() -> Settings:
    """Get development settings"""
    settings = get_settings()
    settings.DEBUG = True
    settings.RELOAD = True
    settings.LOG_LEVEL = "DEBUG"
    return settings


def get_production_settings() -> Settings:
    """Get production settings"""
    settings = get_settings()
    settings.DEBUG = False
    settings.RELOAD = False
    settings.LOG_LEVEL = "INFO"
    settings.SECRET_KEY = os.getenv("SECRET_KEY", settings.SECRET_KEY)
    return settings


def get_test_settings() -> Settings:
    """Get test settings"""
    settings = get_settings()
    settings.DATABASE_NAME = "kobi_firewall_test_db"
    settings.DEBUG = True
    return settings


# Export for easy import
__all__ = ["Settings", "get_settings", "get_development_settings", "get_production_settings", "get_test_settings"]


================================================
File: app/database.py
================================================
import motor.motor_asyncio
import asyncio
import logging
from pymongo.errors import ServerSelectionTimeoutError, OperationFailure, DuplicateKeyError
from datetime import datetime
import hashlib
from .config import get_settings

# Logger setup
logger = logging.getLogger(__name__)

# Global database connection
client = None
database = None


async def connect_to_mongo():
    """Connect to MongoDB"""
    global client, database

    try:
        settings = get_settings()
        logger.info(f"Attempting to connect to MongoDB: {settings.MONGODB_URL}")

        # Create MongoDB client
        client = motor.motor_asyncio.AsyncIOMotorClient(
            settings.MONGODB_URL,
            serverSelectionTimeoutMS=5000,
            maxPoolSize=50,
            minPoolSize=10
        )

        # Test connection
        await client.admin.command('ismaster')

        # Get database
        database = client[settings.DATABASE_NAME]

        # List collections for verification
        collections = await database.list_collection_names()
        logger.info(f"Database connected successfully. Collections: {len(collections)}")

        # Initialize collections and indexes
        await _initialize_collections()

        logger.info(f"✅ Connected to MongoDB: {settings.DATABASE_NAME}")

    except ServerSelectionTimeoutError:
        logger.error("❌ MongoDB connection timeout. Is MongoDB running?")
        raise
    except Exception as e:
        logger.error(f"❌ MongoDB connection failed: {str(e)}")
        raise


async def _initialize_collections():
    """Initialize collections and create indexes"""
    try:
        # Users collection
        users_collection = database.users

        # Create indexes - handle existing indexes gracefully
        try:
            # Check existing indexes
            existing_indexes = await users_collection.list_indexes().to_list(length=None)
            existing_index_names = [idx['name'] for idx in existing_indexes]

            # Create username index if not exists
            if 'username_1' not in existing_index_names:
                await users_collection.create_index("username", unique=True)
                logger.info("Created username index")

            # Handle email index conflict
            if 'email_1' in existing_index_names:
                try:
                    # Check if existing email index needs to be updated
                    email_index = next((idx for idx in existing_indexes if idx['name'] == 'email_1'), None)
                    if email_index and 'sparse' not in email_index:
                        # Drop and recreate with sparse option
                        await users_collection.drop_index("email_1")
                        await users_collection.create_index("email", unique=True, sparse=True)
                        logger.info("Updated email index with sparse option")
                except Exception as e:
                    logger.warning(f"Could not update email index: {e}")
            else:
                await users_collection.create_index("email", unique=True, sparse=True)
                logger.info("Created email index")

        except OperationFailure as e:
            if e.code == 86:  # IndexKeySpecsConflict
                logger.warning(f"Index conflict resolved: {e}")
            else:
                logger.error(f"Index creation failed: {e}")

        # Initialize admin user
        await _initialize_admin_user()

        # Other collections
        try:
            await database.firewall_rules.create_index("rule_id", unique=True, sparse=True)
            await database.logs.create_index("timestamp", expireAfterSeconds=2592000)  # 30 days
            await database.network_activity.create_index("timestamp", expireAfterSeconds=604800)  # 7 days
            logger.info("Additional indexes created successfully")
        except Exception as e:
            logger.warning(f"Additional index creation warning: {e}")

        logger.info("Collections and indexes initialized successfully")

    except Exception as e:
        logger.error(f"Error initializing collections: {e}")
        logger.error(f"Traceback: {str(e)}")


async def _initialize_admin_user():
    """Initialize default admin user if not exists"""
    try:
        users_collection = database.users

        # Check if admin exists
        admin_exists = await users_collection.find_one({"username": "admin"})
        if not admin_exists:
            # Hash admin password
            hashed_password = hashlib.sha256("admin123".encode()).hexdigest()

            admin_user = {
                "username": "admin",
                "email": "admin@netgate.local",
                "password": hashed_password,
                "full_name": "System Administrator",
                "is_active": True,
                "created_at": datetime.utcnow(),
                "last_login": None
            }

            await users_collection.insert_one(admin_user)
            logger.info("✅ Default admin user created (admin/admin123)")
        else:
            # Ensure admin user has required fields
            update_fields = {}
            if "is_active" not in admin_exists:
                update_fields["is_active"] = True
            if "created_at" not in admin_exists:
                update_fields["created_at"] = datetime.utcnow()
            if "email" not in admin_exists:
                update_fields["email"] = "admin@netgate.local"
            if "full_name" not in admin_exists:
                update_fields["full_name"] = "System Administrator"

            if update_fields:
                await users_collection.update_one(
                    {"username": "admin"},
                    {"$set": update_fields}
                )
                logger.info("✅ Admin user updated with missing fields")

            logger.info("✅ Admin user already exists and is up to date")

    except Exception as e:
        logger.error(f"Error initializing admin user: {e}")


async def close_mongo_connection():
    """Close MongoDB connection"""
    global client
    if client:
        client.close()
        logger.info("MongoDB connection closed")


async def get_database():
    """Get database instance"""
    global database
    if database is None:
        await connect_to_mongo()
    return database


# Collection shortcuts
async def get_users_collection():
    db = await get_database()
    return db.users


async def get_logs_collection():
    db = await get_database()
    return db.logs


async def get_firewall_rules_collection():
    db = await get_database()
    return db.firewall_rules


async def get_network_activity_collection():
    db = await get_database()
    return db.network_activity


# Health check
async def check_database_health():
    """Check database health"""
    try:
        if database is None:
            return {"status": "disconnected", "error": "No database connection"}

        # Test connection
        await database.command("ping")

        # Get stats
        stats = await database.command("dbstats")

        return {
            "status": "healthy",
            "database": database.name,
            "collections": stats.get("collections", 0),
            "dataSize": stats.get("dataSize", 0),
            "indexSize": stats.get("indexSize", 0)
        }

    except Exception as e:
        return {
            "status": "error",
            "error": str(e)
        }


# Collection references (will be set after connection)
users_collection = None
logs_collection = None
firewall_rules_collection = None
network_activity_collection = None


async def init_collection_references():
    """Initialize collection references"""
    global users_collection, logs_collection, firewall_rules_collection, network_activity_collection

    try:
        db = await get_database()
        users_collection = db.users
        logs_collection = db.logs
        firewall_rules_collection = db.firewall_rules
        network_activity_collection = db.network_activity
        logger.info("Collection references initialized successfully")
    except Exception as e:
        logger.error(f"Error initializing collection references: {e}")
        raise


================================================
File: app/dependencies.py
================================================
""" Modern dependency injection with enhanced security and async support """
from typing import Optional, Any, Dict
from datetime import datetime, timedelta
from fastapi import Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer, HTTPBearer
from jose import jwt, JWTError
from passlib.context import CryptContext

# Security schemes
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/v1/auth/login")
bearer_scheme = HTTPBearer(auto_error=False)

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class SecurityManager:
    """Enhanced security manager with rate limiting and session management"""

    def __init__(self):
        self.failed_attempts: Dict[str, int] = {}
        self.blocked_ips: Dict[str, datetime] = {}
        self.active_sessions: Dict[str, Dict[str, Any]] = {}

    def is_ip_blocked(self, ip: str) -> bool:
        """Check if IP is temporarily blocked"""
        if ip in self.blocked_ips:
            if datetime.utcnow() - self.blocked_ips[ip] > timedelta(minutes=15):
                del self.blocked_ips[ip]
                return False
            return True
        return False

    def record_failed_attempt(self, ip: str):
        """Record failed authentication attempt"""
        self.failed_attempts[ip] = self.failed_attempts.get(ip, 0) + 1
        if self.failed_attempts[ip] >= 5:
            self.blocked_ips[ip] = datetime.utcnow()

    def clear_failed_attempts(self, ip: str):
        """Clear failed attempts for successful login"""
        self.failed_attempts.pop(ip, None)

    def add_session(self, user_id: str, session_data: Dict[str, Any]):
        """Add active session"""
        self.active_sessions[user_id] = {
            **session_data,
            "last_activity": datetime.utcnow()
        }

    def remove_session(self, user_id: str):
        """Remove active session"""
        self.active_sessions.pop(user_id, None)

    def is_session_valid(self, user_id: str) -> bool:
        """Check if session is still valid"""
        if user_id not in self.active_sessions:
            return False

        last_activity = self.active_sessions[user_id]["last_activity"]
        if datetime.utcnow() - last_activity > timedelta(hours=8):
            self.remove_session(user_id)
            return False
        return True

# Global security manager
security_manager = SecurityManager()

async def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify password against hash"""
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except Exception as e:
        print(f"Password verification error: {e}")
        return False

async def hash_password(password: str) -> str:
    """Hash password"""
    return pwd_context.hash(password)

async def create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:
    """Create JWT access token"""
    from .settings import get_settings
    settings = get_settings()

    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.access_token_expire_minutes)

    to_encode.update({"exp": expire, "iat": datetime.utcnow()})
    encoded_jwt = jwt.encode(to_encode, settings.jwt_secret, algorithm=settings.jwt_algorithm)
    return encoded_jwt

async def verify_token(token: str) -> Dict[str, Any]:
    """Verify and decode JWT token"""
    from .settings import get_settings
    settings = get_settings()

    try:
        payload = jwt.decode(token, settings.jwt_secret, algorithms=[settings.jwt_algorithm])
        return payload
    except JWTError as e:
        print(f"Token verification error: {e}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

def get_database():
    """Get database instance (dependency injection)"""
    from .database import db_manager
    return db_manager.get_database()

async def get_current_user(
    request: Request,
    token: str = Depends(oauth2_scheme),
    db = Depends(get_database)
):
    """Get current authenticated user with enhanced security checks"""
    # Check if IP is blocked
    client_ip = request.client.host if request.client else "unknown"
    if security_manager.is_ip_blocked(client_ip):
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail="IP temporarily blocked due to failed authentication attempts"
        )

    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        payload = await verify_token(token)
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception

        # Get user from database
        user = await db.users.find_one({"username": username})
        if user is None:
            raise credentials_exception

        # Check if user is active
        if not user.get("is_active", True):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User account is disabled"
            )

        # Update last activity in session (optional check)
        user_id = str(user["_id"])
        if user_id in security_manager.active_sessions:
            security_manager.active_sessions[user_id]["last_activity"] = datetime.utcnow()

        # Update user's last seen
        try:
            await db.users.update_one(
                {"_id": user["_id"]},
                {"$set": {"last_seen": datetime.utcnow()}}
            )
        except Exception as e:
            print(f"Failed to update user last seen: {e}")

        return user

    except HTTPException:
        raise
    except Exception as e:
        print(f"Get current user error: {e}")
        raise credentials_exception

async def get_current_active_user(current_user=Depends(get_current_user)):
    """Get current active user"""
    if not current_user.get("is_active", True):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    return current_user

async def require_admin(current_user=Depends(get_current_active_user)):
    """Require admin privileges"""
    if current_user.get("role") != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin privileges required"
        )
    return current_user

async def require_permissions(permissions: list):
    """Require specific permissions"""
    def permission_checker(current_user=Depends(get_current_active_user)):
        user_permissions = current_user.get("permissions", [])
        for permission in permissions:
            if permission not in user_permissions and current_user.get("role") != "admin":
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Permission '{permission}' required"
                )
        return current_user
    return permission_checker

# Rate limiting dependency
async def rate_limit_check(request: Request):
    """Basic rate limiting check"""
    client_ip = request.client.host if request.client else "unknown"

    # Simple rate limiting
    if security_manager.is_ip_blocked(client_ip):
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail="Rate limit exceeded"
        )
    return client_ip


================================================
File: app/dns_proxy.py
================================================
import asyncio
import socket
import struct
from datetime import datetime
from typing import Set, Dict
import dns.message
import dns.query
import dns.resolver
import dns.rcode

class DNSProxyServer:
    """SeÃ§ici DNS engelleme iÃ§in proxy sunucusu"""
    
    def __init__(self, listen_ip='0.0.0.0', listen_port=53):
        self.listen_ip = listen_ip
        self.listen_port = listen_port
        self.blocked_domains: Set[str] = set()
        self.upstream_dns = ['8.8.8.8', '8.8.4.4']  # Google DNS
        self.allowed_clients: Set[str] = set()  # Ä°zin verilen IP'ler
        self.running = False
        self.transport = None
        
    def update_blocked_domains(self, domains: Set[str]):
        """Engellenen domain listesini gÃ¼ncelle"""
        self.blocked_domains = domains
        print(f"Blocked domains updated: {len(domains)} domains")
        
    def add_allowed_client(self, ip: str):
        """Ä°zin verilen client IP'si ekle (sizin PC'niz)"""
        self.allowed_clients.add(ip)
        print(f"Added allowed client: {ip}")
        
    def is_domain_blocked(self, domain: str, client_ip: str) -> bool:
        """Domain'in client iÃ§in engellenip engellenmediÄŸini kontrol et"""
        # EÄŸer client izin verilenler listesindeyse (sizin PC'niz), engelleme
        if client_ip in self.allowed_clients:
            return False
            
        # DiÄŸer clientler iÃ§in (arkadaÅŸÄ±nÄ±zÄ±n PC'si) kontrol et
        domain_lower = domain.lower().rstrip('.')
        
        # Tam eÅŸleÅŸme kontrolÃ¼
        if domain_lower in self.blocked_domains:
            return True
            
        # Subdomain kontrolÃ¼
        parts = domain_lower.split('.')
        for i in range(len(parts)):
            parent = '.'.join(parts[i:])
            if parent in self.blocked_domains:
                return True
                
        return False
        
    async def handle_dns_query(self, data: bytes, addr):
        """DNS sorgusunu iÅŸle"""
        client_ip = addr[0]
        
        try:
            # DNS mesajÄ±nÄ± parse et
            query = dns.message.from_wire(data)
            
            # Sorguyu logla
            for question in query.question:
                domain = str(question.name)
                print(f"DNS query from {client_ip}: {domain}")
                
                # Domain engellenmiÅŸ mi kontrol et
                if self.is_domain_blocked(domain, client_ip):
                    print(f"BLOCKED: {domain} for {client_ip}")
                    # Engelleme cevabÄ± gÃ¶nder (NXDOMAIN)
                    response = dns.message.make_response(query)
                    response.set_rcode(dns.rcode.NXDOMAIN)
                    return response.to_wire()
            
            # Engellenmediyse, upstream DNS'e yÃ¶nlendir
            response_data = await self.forward_to_upstream(data)
            return response_data
            
        except Exception as e:
            print(f"Error handling DNS query: {e}")
            return None
            
    async def forward_to_upstream(self, query_data: bytes) -> bytes:
        """Sorguyu upstream DNS sunucusuna yÃ¶nlendir"""
        for dns_server in self.upstream_dns:
            try:
                # UDP Ã¼zerinden upstream DNS'e gÃ¶nder
                response = await asyncio.wait_for(
                    self._udp_query(query_data, dns_server, 53),
                    timeout=2.0
                )
                return response
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                print(f"Error forwarding to {dns_server}: {e}")
                continue
        return None
        
    async def _udp_query(self, data: bytes, server: str, port: int) -> bytes:
        """UDP DNS sorgusu gÃ¶nder"""
        loop = asyncio.get_event_loop()
        
        # Socket oluÅŸtur
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.setblocking(False)
        
        try:
            # Sorguyu gÃ¶nder
            await loop.sock_sendto(sock, data, (server, port))
            
            # CevabÄ± bekle
            response_data, _ = await loop.sock_recvfrom(sock, 512)
            return response_data
        finally:
            sock.close()
            
    async def start_server(self):
        """DNS proxy sunucusunu baÅŸlat"""
        print(f"Starting DNS proxy on {self.listen_ip}:{self.listen_port}")
        
        # UDP sunucu oluÅŸtur
        loop = asyncio.get_event_loop()
        transport, protocol = await loop.create_datagram_endpoint(
            lambda: DNSProtocol(self),
            local_addr=(self.listen_ip, self.listen_port)
        )
        
        self.running = True
        self.transport = transport
        
        print("DNS proxy server started")
        
    def stop_server(self):
        """Sunucuyu durdur"""
        self.running = False
        if self.transport:
            self.transport.close()
            self.transport = None
        print("DNS proxy server stopped")
            

class DNSProtocol(asyncio.DatagramProtocol):
    """DNS UDP protokol handler"""
    
    def __init__(self, server: DNSProxyServer):
        self.server = server
        self.transport = None
        
    def connection_made(self, transport):
        self.transport = transport
        
    def datagram_received(self, data, addr):
        """DNS paketi alÄ±ndÄ±ÄŸÄ±nda"""
        asyncio.create_task(self._handle_query(data, addr))
        
    async def _handle_query(self, data, addr):
        """Sorguyu iÅŸle ve cevapla"""
        response = await self.server.handle_dns_query(data, addr)
        if response and self.transport:
            self.transport.sendto(response, addr)


================================================
File: app/dns_proxy_manager.py
================================================
import asyncio
import platform
import subprocess
import socket
from typing import Optional, Set
from app.dns_proxy import DNSProxyServer

class DNSProxyManager:
    """DNS Proxy sunucusunu yÃ¶neten sÄ±nÄ±f"""
    
    def __init__(self):
        self.proxy_server: Optional[DNSProxyServer] = None
        self.server_task: Optional[asyncio.Task] = None
        self._running = False
        
    def get_local_ip(self) -> str:
        """Lokal IP adresini al"""
        try:
            # DÄ±ÅŸ bir adrese baÄŸlanmaya Ã§alÄ±ÅŸ (gerÃ§ekten baÄŸlanmaz)
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            local_ip = s.getsockname()[0]
            s.close()
            return local_ip
        except:
            return "127.0.0.1"
            
    async def start_proxy(self, blocked_domains: Set[str], port: int = 53):
        """DNS proxy sunucusunu baÅŸlat"""
        if self._running:
            print("DNS proxy already running")
            return
            
        # Proxy sunucusu oluÅŸtur
        self.proxy_server = DNSProxyServer(listen_ip='0.0.0.0', listen_port=port)
        
        # Kendi IP'mizi allowed listesine ekle
        local_ip = self.get_local_ip()
        self.proxy_server.add_allowed_client(local_ip)
        self.proxy_server.add_allowed_client('127.0.0.1')
        self.proxy_server.add_allowed_client('::1')  # IPv6 localhost
        
        # Engellenen domainleri ayarla
        self.proxy_server.update_blocked_domains(blocked_domains)
        
        # Sunucuyu baÅŸlat
        try:
            await self.proxy_server.start_server()
            self._running = True
        except Exception as e:
            print(f"Failed to start DNS proxy: {e}")
            raise
        
    def stop_proxy(self):
        """DNS proxy sunucusunu durdur"""
        if self.proxy_server:
            self.proxy_server.stop_server()
            self.proxy_server = None
            
        if self.server_task:
            self.server_task.cancel()
            
        self._running = False
            
    def update_blocked_domains(self, domains: Set[str]):
        """Engellenen domain listesini gÃ¼ncelle"""
        if self.proxy_server:
            self.proxy_server.update_blocked_domains(domains)
            
    def is_running(self) -> bool:
        """Proxy'nin Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± kontrol et"""
        return self._running
            
    def configure_windows_dns(self, interface_name: str) -> bool:
        """Windows'ta belirli bir interface iÃ§in DNS ayarla"""
        if platform.system().lower() != "windows":
            return False
            
        local_ip = self.get_local_ip()
        
        try:
            # DNS'i bizim proxy'ye yÃ¶nlendir
            cmd = [
                "netsh", "interface", "ip", "set", "dns",
                f"name={interface_name}",
                "static", local_ip, "primary"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode != 0:
                print(f"DNS configuration failed: {result.stderr}")
                return False
                
            # Ä°kincil DNS olarak Google DNS ekle (fallback)
            cmd2 = [
                "netsh", "interface", "ip", "add", "dns",
                f"name={interface_name}",
                "8.8.8.8", "index=2"
            ]
            subprocess.run(cmd2, capture_output=True, text=True)
            
            # DNS Ã¶nbelleÄŸini temizle
            subprocess.run(["ipconfig", "/flushdns"], capture_output=True, text=True)
            
            print(f"DNS configured for {interface_name}: {local_ip}")
            return True
            
        except Exception as e:
            print(f"Error configuring DNS: {e}")
            return False
        
    def restore_windows_dns(self, interface_name: str) -> bool:
        """DNS ayarlarÄ±nÄ± eski haline getir"""
        if platform.system().lower() != "windows":
            return False
            
        try:
            cmd = [
                "netsh", "interface", "ip", "set", "dns",
                f"name={interface_name}",
                "dhcp"
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            # DNS Ã¶nbelleÄŸini temizle
            subprocess.run(["ipconfig", "/flushdns"], capture_output=True, text=True)
            
            print(f"DNS restored to DHCP for {interface_name}")
            return result.returncode == 0
            
        except Exception as e:
            print(f"Error restoring DNS: {e}")
            return False
        
        
# Global proxy manager instance
dns_proxy_manager = DNSProxyManager()


================================================
File: app/firewall_driver.py
================================================
class FirewallDriver:
    """
    Ortak (base) bir firewall sÃ¼rÃ¼cÃ¼ sÄ±nÄ±fÄ±.
    Windows veya Linux alt sÄ±nÄ±flar bunu miras alarak
    add_rule, remove_rule, update_rule metodlarÄ±nÄ± uygular.
    """
    def add_rule(self, rule):
        raise NotImplementedError

    def remove_rule(self, rule_name):
        raise NotImplementedError

    def update_rule(self, old_rule, new_rule):
        raise NotImplementedError



================================================
File: app/firewall_os.py
================================================
import platform
from app.linux_firewall import LinuxFirewall
from app.win_firewall import WinFirewall

def remove_firewall_rule_os(rule_name: str):
    sysname = platform.system().lower()
    if sysname.startswith("win"):
        fw = WinFirewall()
        fw.remove_rule(rule_name)
    else:
        fw = LinuxFirewall()
        fw.remove_rule(rule_name)

def add_firewall_rule_os(rule):
    sysname = platform.system().lower()
    if sysname.startswith("win"):
        fw = WinFirewall()
    else:
        fw = LinuxFirewall()
    fw.add_rule(rule)

def update_firewall_rule_os(old_rule, new_rule):
    sysname = platform.system().lower()
    if sysname.startswith("win"):
        fw = WinFirewall()
    else:
        fw = LinuxFirewall()
    fw.update_rule(old_rule, new_rule)



================================================
File: app/linux_firewall.py
================================================
import subprocess
from fastapi import HTTPException
from app.firewall_driver import FirewallDriver

day_mapping = ["MO","TU","WE","TH","FR","SA","SU"]

def build_time_params(rule):
    time_params = []
    if rule.get("schedule_start") and rule.get("schedule_end"):
        start_str = rule["schedule_start"]
        end_str = rule["schedule_end"]
        time_params = ["-m", "time", "--timestart", start_str, "--timestop", end_str]

        if rule.get("days_of_week"):
            valid_days = []
            for d in rule["days_of_week"]:
                if 0 <= d <= 6:
                    valid_days.append(day_mapping[d])
            if valid_days:
                day_str = ",".join(valid_days)
                time_params += ["--days", day_str]
    return time_params

class LinuxFirewall(FirewallDriver):
    def add_rule(self, rule):
        chain = "INPUT" if rule["direction"].upper() == "IN" else "OUTPUT"
        if rule["action"].upper() == "ALLOW":
            target = "ACCEPT"
            log_prefix = None
        else:
            target = "DROP"
            log_prefix = "FWDROP: "

        proto = rule.get("protocol","tcp").lower()
        src_ip = "0.0.0.0/0"
        if rule.get("source_ips"):
            src_ip = rule["source_ips"][0]

        # 1) LOG kuralÄ± (DENY ise)
        if log_prefix:
            log_cmd = [
                "iptables", "-A", chain,
                "-p", proto,
                "-s", src_ip
            ]
            if rule.get("port"):
                if chain == "INPUT":
                    log_cmd += ["--dport", str(rule["port"])]
                else:
                    log_cmd += ["--sport", str(rule["port"])]
            log_cmd += build_time_params(rule)
            log_cmd += [
                "-m", "comment", "--comment", rule["rule_name"],
                "-j", "LOG", "--log-prefix", log_prefix
            ]
            res_log = subprocess.run(log_cmd, capture_output=True, text=True)
            if res_log.returncode != 0:
                raise HTTPException(400, f"Linux firewall add rule LOG error: {res_log.stderr.strip()}")

        # 2) AsÄ±l kural
        ip_cmd = [
            "iptables", "-A", chain,
            "-p", proto,
            "-s", src_ip
        ]
        if rule.get("port"):
            if chain == "INPUT":
                ip_cmd += ["--dport", str(rule["port"])]
            else:
                ip_cmd += ["--sport", str(rule["port"])]

        ip_cmd += build_time_params(rule)
        ip_cmd += [
            "-m", "comment", "--comment", rule["rule_name"],
            "-j", target
        ]

        res = subprocess.run(ip_cmd, capture_output=True, text=True)
        if res.returncode != 0:
            raise HTTPException(400, f"Linux firewall add rule error: {res.stderr.strip()}")

    def remove_rule(self, rule_name):
        # iptables -D ... vs. (henÃ¼z tam uygulanmadÄ±)
        pass

    def update_rule(self, old_rule, new_rule):
        self.remove_rule(old_rule["rule_name"])
        self.add_rule(new_rule)



================================================
File: app/log_watchers.py
================================================
import asyncio
import re
import platform
import subprocess
from datetime import datetime, timedelta

from app.database import db

FWDROP_REGEX = re.compile(r"FWDROP:")

async def iptables_log_watcher():
    """
    Basit bir syslog (tail -F) takibi yaparak 'FWDROP:' prefixli satÄ±rlarÄ±
    blocked_packets koleksiyonuna ekler. Sadece Linux Ã¶rneÄŸi.
    """
    if not platform.system().lower().startswith("linux"):
        return

    cmd = ["tail", "-F", "/var/log/syslog"]
    process = await asyncio.create_subprocess_exec(
        *cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )

    while True:
        line = await process.stdout.readline()
        if not line:
            await asyncio.sleep(0.1)
            continue

        if "FWDROP:" in line:
            doc = {
                "timestamp": datetime.utcnow(),
                "raw_log_line": line.strip()
            }
            await db["blocked_packets"].insert_one(doc)

            await check_blocked_alarm()

async def check_blocked_alarm():
    """
    Basit alarm kontrolÃ¼: Son 5 dk iÃ§inde 50'den fazla DROP varsa 'ALERT' log ekler.
    """
    now = datetime.utcnow()
    cutoff = now - timedelta(minutes=5)
    count_last_5min = await db["blocked_packets"].count_documents({"timestamp": {"$gte": cutoff}})

    if count_last_5min > 50:
        alarm_doc = {
            "timestamp": now,
            "level": "ALERT",
            "message": f"Son 5 dakika iÃ§inde {count_last_5min} DROP tespit edildi!"
        }
        await db["logs"].insert_one(alarm_doc)


async def advanced_log_analysis_task():
    """
    Her 5 dakikada bir, 'logs' tablosunda Ã§ok fazla DENY (firewall_rules) varsa alert Ã¼retir.
    Ã–r: son 10 dakikada 100'den fazla DENY log kaydÄ± -> 'alerts' koleksiyonuna ekle
    """
    while True:
        now = datetime.utcnow()
        cutoff = now - timedelta(minutes=10)

        query = {
            "timestamp": {"$gte": cutoff},
            "level": "INFO",
            "message": {"$regex": "DENY|DROP"}
        }
        count_deny = await db["logs"].count_documents(query)

        if count_deny > 100:
            alert_doc = {
                "timestamp": now,
                "level": "ALERT",
                "message": f"Son 10 dk iÃ§inde {count_deny} adet DENY log kaydÄ± tespit edildi!"
            }
            await db["alerts"].insert_one(alert_doc)

        await asyncio.sleep(300)  # 5 dk

async def start_log_watchers():
    asyncio.create_task(iptables_log_watcher())
    asyncio.create_task(advanced_log_analysis_task())



================================================
File: app/main.py
================================================
import logging
import uvicorn
from datetime import datetime
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.responses import JSONResponse
from contextlib import asynccontextmanager
import time

# Import configurations and database
from .config import get_settings
from .database import connect_to_mongo, close_mongo_connection, get_database, init_collection_references

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('kobi_firewall.log', encoding='utf-8')
    ]
)

logger = logging.getLogger(__name__)

# Settings
settings = get_settings()
logger.info(f"[OK] Settings loaded: {settings.APP_NAME}")


# Lifespan context manager for startup and shutdown events
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    logger.info("[PROC] Starting KOBI Firewall...")
    try:
        # Connect to database
        await connect_to_mongo()
        logger.info("[OK] Database connected")

        # Initialize collection references
        await init_collection_references()
        logger.info("[OK] Collection references initialized")

        # Initialize admin user (if needed)
        try:
            from .database import _initialize_admin_user
            await _initialize_admin_user()
            logger.info("[OK] Admin user checked/initialized")
        except Exception as e:
            logger.warning(f"[WARN] Admin initialization warning: {e}")

        logger.info("[OK] KOBI Firewall startup completed successfully")

    except Exception as e:
        logger.error(f"[ERROR] Startup failed: {e}")
        raise

    yield  # Application runs here

    # Shutdown
    logger.info("[PROC] Shutting down KOBI Firewall...")
    try:
        await close_mongo_connection()
        logger.info("[OK] Database connection closed")
    except Exception as e:
        logger.error(f"[ERROR] Shutdown error: {e}")


# Create FastAPI application with lifespan
app = FastAPI(
    title=settings.APP_NAME,
    description="KOBI Firewall Management System - Advanced Network Security Platform",
    version="2.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
    lifespan=lifespan
)

# CORS Configuration
origins = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "http://localhost:3001",
    "http://127.0.0.1:3001",
    "http://localhost:5173",
    "http://127.0.0.1:5173",
    "*"  # Allow all origins for development
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
    allow_headers=["*"],
    expose_headers=["*"]
)

logger.info(f"[OK] CORS configured with origins: {origins}")


# Request/Response Logging Middleware
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()

    # Log request
    logger.info(f"[REQUEST] {request.method} {request.url}")

    try:
        # Process request
        response = await call_next(request)

        # Calculate processing time
        process_time = time.time() - start_time

        # Log response
        logger.info(f"[RESPONSE] {response.status_code} - {process_time:.4f}s")

        return response

    except Exception as e:
        process_time = time.time() - start_time
        logger.error(f"[ERROR] Request failed: {str(e)} - {process_time:.4f}s")
        raise


# Auth router ile basit import
try:
    from .routers.auth_simple import router as auth_router

    app.include_router(auth_router)
    logger.info("[OK] Simple Auth router included")
except Exception as e:
    logger.error(f"[ERROR] Auth router failed: {e}")

# System router
try:
    from .routers.system import router as system_router

    app.include_router(system_router)
    logger.info("[OK] System router included")
except Exception as e:
    logger.error(f"[ERROR] System router failed: {e}")


# Root endpoint
@app.get("/")
async def root():
    """Root endpoint with API information"""
    return {
        "message": "KOBI Firewall API",
        "version": "2.0.0",
        "status": "running",
        "timestamp": datetime.utcnow().isoformat(),
        "docs_url": "/docs",
        "health_check": "/health"
    }


# Health check endpoint
@app.get("/health")
async def health_check():
    """Comprehensive health check endpoint"""
    try:
        # Check database connection
        db_health = {"status": "unknown"}
        try:
            from .database import check_database_health
            db_health = await check_database_health()
        except Exception as e:
            db_health = {"status": "error", "error": str(e)}

        health_response = {
            "status": "healthy",
            "service": settings.APP_NAME,
            "version": "2.0.0",
            "timestamp": datetime.utcnow().isoformat(),
            "message": f"{settings.APP_NAME} is running",
            "database": db_health,
            "auth": "simple"
        }

        logger.info(f"Health check successful")
        return health_response

    except Exception as e:
        logger.error(f"Health check failed: {str(e)}")
        return {
            "status": "error",
            "service": settings.APP_NAME,
            "version": "2.0.0",
            "timestamp": datetime.utcnow().isoformat(),
            "message": f"Health check failed: {str(e)}"
        }


if __name__ == "__main__":
    logger.info("Starting KOBI Firewall in development mode...")
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info",
        access_log=True
    )


================================================
File: app/middleware.py
================================================
"""
Custom middleware for security, logging, and monitoring
"""
import time
import json
import uuid
from datetime import datetime
from typing import Dict, Any, Optional
from fastapi import Request, Response
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.types import ASGIApp
from .database import db_manager
from .settings import get_settings

settings = get_settings()

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    """Add security headers to all responses"""

    def __init__(self, app: ASGIApp):
        super().__init__(app)

    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)

        # Security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
        response.headers["Permissions-Policy"] = "geolocation=(), microphone=(), camera=()"

        # Only add HSTS in production with HTTPS
        if settings.is_production and request.url.scheme == "https":
            response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"

        # Content Security Policy
        csp_policy = (
            "default-src 'self'; "
            "script-src 'self' 'unsafe-inline' 'unsafe-eval'; "
            "style-src 'self' 'unsafe-inline'; "
            "img-src 'self' data: https:; "
            "font-src 'self' data:; "
            "connect-src 'self' ws: wss:; "
            "frame-ancestors 'none';"
        )
        response.headers["Content-Security-Policy"] = csp_policy

        # API-specific headers
        response.headers["X-API-Version"] = settings.version
        response.headers["X-Service-Name"] = settings.project_name

        return response

class LoggingMiddleware(BaseHTTPMiddleware):
    """Enhanced logging middleware with structured logging"""

    def __init__(self, app: ASGIApp):
        super().__init__(app)

    async def dispatch(self, request: Request, call_next):
        # Generate request ID
        request_id = str(uuid.uuid4())

        # Add request ID to headers
        request.state.request_id = request_id

        # Start timing
        start_time = time.time()

        # Get request details
        client_ip = self.get_client_ip(request)
        user_agent = request.headers.get("user-agent", "")

        # Log request
        request_log = {
            "request_id": request_id,
            "method": request.method,
            "path": request.url.path,
            "query_params": dict(request.query_params),
            "client_ip": client_ip,
            "user_agent": user_agent,
            "timestamp": datetime.utcnow().isoformat(),
            "event": "request_start"
        }

        # Process request
        try:
            response = await call_next(request)

            # Calculate processing time
            process_time = time.time() - start_time

            # Log response
            response_log = {
                "request_id": request_id,
                "status_code": response.status_code,
                "process_time_ms": round(process_time * 1000, 2),
                "response_size": response.headers.get("content-length", "unknown"),
                "timestamp": datetime.utcnow().isoformat(),
                "event": "request_complete"
            }

            # Add to database if not health check
            if not request.url.path.startswith("/health"):
                try:
                    await self.log_to_database(request_log, response_log)
                except Exception as log_error:
                    print(f"Failed to log to database: {log_error}")

            # Add timing header
            response.headers["X-Process-Time"] = str(process_time)
            response.headers["X-Request-ID"] = request_id

            return response

        except Exception as e:
            # Log error
            error_log = {
                "request_id": request_id,
                "error": str(e),
                "error_type": type(e).__name__,
                "process_time_ms": round((time.time() - start_time) * 1000, 2),
                "timestamp": datetime.utcnow().isoformat(),
                "event": "request_error"
            }
            try:
                await self.log_to_database(request_log, error_log)
            except Exception as log_error:
                print(f"Failed to log error to database: {log_error}")
            raise

    def get_client_ip(self, request: Request) -> str:
        """Get client IP address with proxy support"""
        # Check for forwarded headers (reverse proxy)
        forwarded_for = request.headers.get("x-forwarded-for")
        if forwarded_for:
            return forwarded_for.split(",")[0].strip()

        real_ip = request.headers.get("x-real-ip")
        if real_ip:
            return real_ip

        return request.client.host if request.client else "unknown"

    async def log_to_database(self, request_log: Dict[str, Any], response_log: Dict[str, Any]):
        """Store request/response logs in database"""
        # Check if database manager and database are available
        if db_manager is None or db_manager.database is None:
            return

        log_entry = {
            **request_log,
            **response_log,
            "timestamp": datetime.utcnow(),
            "level": "INFO",
            "source": "http_middleware",
            "message": f"{request_log['method']} {request_log['path']} - {response_log.get('status_code', 'ERROR')}"
        }

        await db_manager.database.system_logs.insert_one(log_entry)

class ErrorHandlerMiddleware(BaseHTTPMiddleware):
    """Global error handling middleware"""

    def __init__(self, app: ASGIApp):
        super().__init__(app)

    async def dispatch(self, request: Request, call_next):
        try:
            return await call_next(request)
        except Exception as e:
            return await self.handle_error(request, e)

    async def handle_error(self, request: Request, error: Exception) -> JSONResponse:
        """Handle unexpected errors with proper logging"""
        request_id = getattr(request.state, 'request_id', 'unknown')

        error_data = {
            "request_id": request_id,
            "error_type": type(error).__name__,
            "error_message": str(error),
            "path": request.url.path,
            "method": request.method,
            "timestamp": datetime.utcnow().isoformat()
        }

        # Log to database
        try:
            if db_manager and db_manager.database:
                await db_manager.database.system_logs.insert_one({
                    **error_data,
                    "level": "ERROR",
                    "source": "error_middleware",
                    "message": f"Unhandled error in {request.method} {request.url.path}: {str(error)}"
                })
        except Exception:
            pass  # Don't fail if logging fails

        # Return error response
        if settings.is_development:
            import traceback
            error_data["traceback"] = traceback.format_exc()

        return JSONResponse(
            status_code=500,
            content={
                "success": False,
                "message": "Internal server error",
                "error_code": "INTERNAL_ERROR",
                "request_id": request_id,
                "details": error_data if settings.is_development else None
            }
        )


================================================
File: app/models.py
================================================
"""
Pydantic v2 models with enhanced validation and serialization
"""

from datetime import datetime
from typing import Optional, List, Dict, Any, Union
from enum import Enum

from pydantic import BaseModel, Field, validator, ConfigDict
from bson import ObjectId


class PyObjectId(ObjectId):
    """Custom ObjectId type for Pydantic v2"""

    @classmethod
    def __get_validators__(cls):
        yield cls.validate

    @classmethod
    def validate(cls, v):
        if not ObjectId.is_valid(v):
            raise ValueError("Invalid ObjectId")
        return ObjectId(v)

    @classmethod
    def __modify_schema__(cls, field_schema):
        field_schema.update(type="string")


class BaseDbModel(BaseModel):
    """Base model for database documents"""

    model_config = ConfigDict(
        populate_by_name=True,
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )

    id: Optional[PyObjectId] = Field(alias="_id", default=None)
    created_at: Optional[datetime] = Field(default_factory=datetime.utcnow)
    updated_at: Optional[datetime] = None


class UserRole(str, Enum):
    """User roles enumeration"""
    ADMIN = "admin"
    OPERATOR = "operator"
    VIEWER = "viewer"


class User(BaseDbModel):
    """User model with enhanced security features"""

    username: str = Field(..., min_length=3, max_length=50)
    email: Optional[str] = Field(None, regex=r'^[^@]+@[^@]+\.[^@]+$')
    hashed_password: str
    role: UserRole = UserRole.VIEWER
    is_active: bool = True
    is_verified: bool = False
    last_login: Optional[datetime] = None
    last_seen: Optional[datetime] = None
    failed_login_attempts: int = 0
    locked_until: Optional[datetime] = None
    settings: Dict[str, Any] = Field(default_factory=dict)
    permissions: List[str] = Field(default_factory=list)

    @validator('username')
    def validate_username(cls, v):
        if not v.replace('_', '').replace('-', '').isalnum():
            raise ValueError('Username must contain only alphanumeric characters, hyphens, and underscores')
        return v.lower()


class FirewallAction(str, Enum):
    """Firewall action types"""
    ALLOW = "ALLOW"
    DENY = "DENY"
    DROP = "DROP"
    REJECT = "REJECT"


class FirewallDirection(str, Enum):
    """Firewall direction types"""
    IN = "IN"
    OUT = "OUT"
    BOTH = "BOTH"


class FirewallProtocol(str, Enum):
    """Firewall protocol types"""
    TCP = "TCP"
    UDP = "UDP"
    ICMP = "ICMP"
    ANY = "ANY"


class FirewallRule(BaseDbModel):
    """Enhanced firewall rule model"""

    rule_name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)

    # Network configuration
    source_ips: List[str] = Field(default_factory=list)
    destination_ips: List[str] = Field(default_factory=list)
    source_ports: List[str] = Field(default_factory=list)
    destination_ports: List[str] = Field(default_factory=list)

    # Rule configuration
    protocol: FirewallProtocol = FirewallProtocol.ANY
    action: FirewallAction = FirewallAction.ALLOW
    direction: FirewallDirection = FirewallDirection.IN

    # Advanced settings
    enabled: bool = True
    priority: int = Field(default=100, ge=1, le=1000)
    profile: str = "Any"
    interface: Optional[str] = None

    # Scheduling
    schedule_start: Optional[str] = Field(None, regex=r'^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$')
    schedule_end: Optional[str] = Field(None, regex=r'^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$')
    days_of_week: List[int] = Field(default_factory=list)

    # Grouping
    group_id: Optional[str] = None
    tags: List[str] = Field(default_factory=list)

    # Statistics
    hit_count: int = 0
    last_hit: Optional[datetime] = None

    @validator('source_ips', 'destination_ips', each_item=True)
    def validate_ip_addresses(cls, v):
        import ipaddress
        try:
            ipaddress.ip_network(v, strict=False)
        except ValueError:
            raise ValueError(f'Invalid IP address or network: {v}')
        return v

    @validator('days_of_week', each_item=True)
    def validate_days_of_week(cls, v):
        if not 0 <= v <= 6:
            raise ValueError('Day of week must be between 0 (Monday) and 6 (Sunday)')
        return v


class FirewallGroup(BaseDbModel):
    """Firewall rule group model"""

    group_name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    enabled: bool = True
    rule_count: int = 0
    tags: List[str] = Field(default_factory=list)


class NetworkInterface(BaseDbModel):
    """Network interface configuration model"""

    interface_name: str = Field(..., min_length=1, max_length=50)
    display_name: Optional[str] = None

    # IP Configuration
    ip_mode: str = Field(default="static")  # static, dhcp
    ip_address: Optional[str] = None
    subnet_mask: Optional[str] = None
    gateway: Optional[str] = None

    # DNS Configuration
    dns_primary: Optional[str] = None
    dns_secondary: Optional[str] = None

    # Interface Settings
    admin_enabled: bool = True
    mtu: Optional[int] = Field(None, ge=576, le=9000)
    vlan_id: Optional[int] = Field(None, ge=0, le=4094)

    # Status Information
    link_state: Optional[str] = None
    admin_state: Optional[str] = None
    mac_address: Optional[str] = None
    speed: Optional[str] = None
    duplex: Optional[str] = None

    @validator('ip_address', 'gateway', 'dns_primary', 'dns_secondary')
    def validate_ip_address(cls, v):
        if v is not None:
            import ipaddress
            try:
                ipaddress.ip_address(v)
            except ValueError:
                raise ValueError(f'Invalid IP address: {v}')
        return v


class StaticRoute(BaseDbModel):
    """Static route configuration model"""

    destination: str = Field(..., description="Destination network")
    mask: str = Field(..., description="Subnet mask")
    gateway: str = Field(..., description="Gateway IP address")
    interface_name: Optional[str] = None
    metric: int = Field(default=1, ge=1, le=9999)
    enabled: bool = True
    description: Optional[str] = Field(None, max_length=200)

    @validator('destination', 'gateway')
    def validate_ip_address(cls, v):
        import ipaddress
        try:
            ipaddress.ip_address(v)
        except ValueError:
            raise ValueError(f'Invalid IP address: {v}')
        return v


class BlockedDomain(BaseDbModel):
    """Blocked domain model for DNS filtering"""

    domain: str = Field(..., min_length=1, max_length=255)
    note: Optional[str] = Field(None, max_length=200)
    use_wildcard: bool = True
    category: Optional[str] = None
    source: Optional[str] = None  # manual, adblock, etc.
    hit_count: int = 0
    last_blocked: Optional[datetime] = None

    @validator('domain')
    def validate_domain(cls, v):
        import re
        domain_pattern = r'^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$'
        if not re.match(domain_pattern, v):
            raise ValueError('Invalid domain format')
        return v.lower()


class SystemLog(BaseDbModel):
    """System log entry model"""

    timestamp: datetime = Field(default_factory=datetime.utcnow)
    level: str = Field(..., regex=r'^(DEBUG|INFO|WARNING|ERROR|CRITICAL)$')
    source: str = Field(..., max_length=100)
    message: str = Field(..., max_length=1000)
    details: Optional[Dict[str, Any]] = None
    user_id: Optional[str] = None
    source_ip: Optional[str] = None
    user_agent: Optional[str] = None


class SecurityAlert(BaseDbModel):
    """Security alert model"""

    alert_type: str = Field(..., max_length=50)
    severity: str = Field(..., regex=r'^(LOW|MEDIUM|HIGH|CRITICAL)$')
    title: str = Field(..., max_length=200)
    description: str = Field(..., max_length=1000)
    source_ip: Optional[str] = None
    target_ip: Optional[str] = None
    port: Optional[int] = None
    protocol: Optional[str] = None
    rule_id: Optional[str] = None
    acknowledged: bool = False
    acknowledged_by: Optional[str] = None
    acknowledged_at: Optional[datetime] = None
    resolved: bool = False
    resolved_at: Optional[datetime] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)


class SystemConfig(BaseDbModel):
    """System configuration model"""

    config_key: str = Field(..., max_length=100)
    config_value: Union[str, int, bool, Dict[str, Any]]
    description: Optional[str] = Field(None, max_length=500)
    category: str = Field(default="general")
    is_sensitive: bool = False
    modified_by: Optional[str] = None


================================================
File: app/schemas.py
================================================
"""
Request/Response schemas for API endpoints using Pydantic v2
"""
from datetime import datetime
from typing import Optional, List, Dict, Any, Union
from enum import Enum
from pydantic import BaseModel, Field, validator, ConfigDict

class ResponseModel(BaseModel):
    """Base response model"""
    model_config = ConfigDict(from_attributes=True)
    success: bool = True
    message: Optional[str] = None
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    details: Optional[Dict[str, Any]] = None

class ErrorResponse(ResponseModel):
    """Error response model"""
    success: bool = False
    error_code: Optional[str] = None
    details: Optional[Dict[str, Any]] = None

class PaginatedResponse(ResponseModel):
    """Paginated response model"""
    data: List[Any]
    total: int
    page: int = 1
    per_page: int = 50
    pages: int
    has_next: bool
    has_prev: bool

# Authentication Schemas
class UserRegister(BaseModel):
    """User registration schema"""
    username: str = Field(..., min_length=3, max_length=50)
    email: Optional[str] = Field(None)
    password: str = Field(..., min_length=8, max_length=128)
    confirm_password: str

    @validator('confirm_password')
    def passwords_match(cls, v, values):
        if 'password' in values and v != values['password']:
            raise ValueError('Passwords do not match')
        return v

    @validator('password')
    def validate_password_strength(cls, v):
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters long')
        if not any(c.isupper() for c in v):
            raise ValueError('Password must contain at least one uppercase letter')
        if not any(c.islower() for c in v):
            raise ValueError('Password must contain at least one lowercase letter')
        if not any(c.isdigit() for c in v):
            raise ValueError('Password must contain at least one digit')
        return v

class UserLogin(BaseModel):
    """User login schema"""
    username: str = Field(..., min_length=1)
    password: str = Field(..., min_length=1)
    remember_me: bool = False

class UserResponse(BaseModel):
    """User response schema"""
    id: str
    username: str
    email: Optional[str] = None
    role: str
    is_active: bool
    created_at: datetime
    last_login: Optional[datetime] = None
    last_seen: Optional[datetime] = None

class TokenResponse(BaseModel):
    """Token response schema"""
    access_token: str
    token_type: str = "bearer"
    expires_in: int
    refresh_token: Optional[str] = None
    user: UserResponse

class PasswordChange(BaseModel):
    """Password change schema"""
    current_password: str
    new_password: str = Field(..., min_length=8)
    confirm_password: str

    @validator('confirm_password')
    def passwords_match(cls, v, values):
        if 'new_password' in values and v != values['new_password']:
            raise ValueError('Passwords do not match')
        return v

# Firewall Schemas
class FirewallRuleCreate(BaseModel):
    """Firewall rule creation schema"""
    rule_name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    source_ips: List[str] = Field(default_factory=list)
    destination_ips: List[str] = Field(default_factory=list)
    source_ports: List[str] = Field(default_factory=list)
    destination_ports: List[str] = Field(default_factory=list)
    protocol: str = "ANY"
    action: str = "ALLOW"
    direction: str = "IN"
    enabled: bool = True
    priority: int = Field(default=100, ge=1, le=1000)
    profile: str = "Any"
    interface: Optional[str] = None
    schedule_start: Optional[str] = Field(None)
    schedule_end: Optional[str] = Field(None)
    days_of_week: List[int] = Field(default_factory=list)
    group_id: Optional[str] = None
    tags: List[str] = Field(default_factory=list)

class FirewallRuleUpdate(BaseModel):
    """Firewall rule update schema"""
    rule_name: Optional[str] = Field(None, min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    source_ips: Optional[List[str]] = None
    destination_ips: Optional[List[str]] = None
    source_ports: Optional[List[str]] = None
    destination_ports: Optional[List[str]] = None
    protocol: Optional[str] = None
    action: Optional[str] = None
    direction: Optional[str] = None
    enabled: Optional[bool] = None
    priority: Optional[int] = Field(None, ge=1, le=1000)
    profile: Optional[str] = None
    interface: Optional[str] = None
    schedule_start: Optional[str] = Field(None)
    schedule_end: Optional[str] = Field(None)
    days_of_week: Optional[List[int]] = None
    group_id: Optional[str] = None
    tags: Optional[List[str]] = None

class FirewallRuleResponse(BaseModel):
    """Firewall rule response schema"""
    id: str
    rule_name: str
    description: Optional[str] = None
    source_ips: List[str]
    destination_ips: List[str]
    source_ports: List[str]
    destination_ports: List[str]
    protocol: str
    action: str
    direction: str
    enabled: bool
    priority: int
    profile: str
    interface: Optional[str] = None
    schedule_start: Optional[str] = None
    schedule_end: Optional[str] = None
    days_of_week: List[int]
    group_id: Optional[str] = None
    tags: List[str]
    hit_count: int = 0
    last_hit: Optional[datetime] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

class FirewallGroupCreate(BaseModel):
    """Firewall group creation schema"""
    group_name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    enabled: bool = True
    tags: List[str] = Field(default_factory=list)

class FirewallGroupResponse(BaseModel):
    """Firewall group response schema"""
    id: str
    group_name: str
    description: Optional[str] = None
    enabled: bool
    rule_count: int
    tags: List[str]
    created_at: datetime
    updated_at: Optional[datetime] = None

# Network Schemas
class NetworkInterfaceCreate(BaseModel):
    """Network interface creation schema"""
    interface_name: str = Field(..., min_length=1, max_length=50)
    display_name: Optional[str] = None
    ip_mode: str = "static"
    ip_address: Optional[str] = None
    subnet_mask: Optional[str] = None
    gateway: Optional[str] = None
    dns_primary: Optional[str] = None
    dns_secondary: Optional[str] = None
    admin_enabled: bool = True
    mtu: Optional[int] = Field(None, ge=576, le=9000)
    vlan_id: Optional[int] = Field(None, ge=0, le=4094)

class NetworkInterfaceResponse(BaseModel):
    """Network interface response schema"""
    id: str
    interface_name: str
    display_name: Optional[str] = None
    ip_mode: str
    ip_address: Optional[str] = None
    subnet_mask: Optional[str] = None
    gateway: Optional[str] = None
    dns_primary: Optional[str] = None
    dns_secondary: Optional[str] = None
    admin_enabled: bool
    mtu: Optional[int] = None
    vlan_id: Optional[int] = None
    link_state: Optional[str] = None
    admin_state: Optional[str] = None
    mac_address: Optional[str] = None
    speed: Optional[str] = None
    duplex: Optional[str] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

class StaticRouteCreate(BaseModel):
    """Static route creation schema"""
    destination: str
    mask: str
    gateway: str
    interface_name: Optional[str] = None
    metric: int = Field(default=1, ge=1, le=9999)
    enabled: bool = True
    description: Optional[str] = Field(None, max_length=200)

class StaticRouteResponse(BaseModel):
    """Static route response schema"""
    id: str
    destination: str
    mask: str
    gateway: str
    interface_name: Optional[str] = None
    metric: int
    enabled: bool
    description: Optional[str] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

# DNS Schemas
class BlockedDomainCreate(BaseModel):
    """Blocked domain creation schema"""
    domain: str = Field(..., min_length=1, max_length=255)
    note: Optional[str] = Field(None, max_length=200)
    use_wildcard: bool = True
    category: Optional[str] = None

class BlockedDomainResponse(BaseModel):
    """Blocked domain response schema"""
    id: str
    domain: str
    note: Optional[str] = None
    use_wildcard: bool
    category: Optional[str] = None
    source: Optional[str] = None
    hit_count: int = 0
    last_blocked: Optional[datetime] = None
    created_at: datetime

class AdblockListImport(BaseModel):
    """Adblock list import schema"""
    url: str = Field(..., min_length=1)
    category: Optional[str] = None
    overwrite_existing: bool = False

# System Schemas
class SystemLogResponse(BaseModel):
    """System log response schema"""
    id: str
    timestamp: datetime
    level: str
    source: str
    message: str
    details: Optional[Dict[str, Any]] = None
    user_id: Optional[str] = None
    source_ip: Optional[str] = None

class SecurityAlertResponse(BaseModel):
    """Security alert response schema"""
    id: str
    alert_type: str
    severity: str
    title: str
    description: str
    source_ip: Optional[str] = None
    target_ip: Optional[str] = None
    port: Optional[int] = None
    protocol: Optional[str] = None
    acknowledged: bool
    acknowledged_by: Optional[str] = None
    acknowledged_at: Optional[datetime] = None
    resolved: bool
    resolved_at: Optional[datetime] = None
    created_at: datetime

class SystemStatsResponse(BaseModel):
    """System statistics response schema"""
    cpu_usage: float
    memory_usage: float
    disk_usage: float
    network_interfaces: List[Dict[str, Any]]
    uptime_seconds: int
    firewall_rules_count: int
    active_rules_count: int
    blocked_domains_count: int
    logs_count_24h: int
    alerts_count_24h: int
    blocked_requests_24h: int
    timestamp: datetime

# Configuration Schemas
class NATConfig(BaseModel):
    """NAT configuration schema"""
    enabled: bool = False
    wan_interface: Optional[str] = None
    lan_interface: Optional[str] = None
    port_forwarding_rules: List[Dict[str, Any]] = Field(default_factory=list)

class DNSProxyConfig(BaseModel):
    """DNS proxy configuration schema"""
    enabled: bool = False
    listen_port: int = Field(default=53, ge=1, le=65535)
    upstream_servers: List[str] = Field(default_factory=lambda: ["8.8.8.8", "8.8.4.4"])
    block_malware: bool = True
    block_ads: bool = False
    custom_records: List[Dict[str, str]] = Field(default_factory=list)


================================================
File: app/settings.py
================================================
"""
Settings management using Pydantic v2 with 12-Factor App principles
"""

import os
from functools import lru_cache
from typing import List, Optional, Union
from pydantic import Field, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    """Application settings with environment variable support"""

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
        extra="ignore"
    )

    # Project Information
    project_name: str = Field(default="KOBI Firewall", description="Project name")
    version: str = Field(default="2.0.0", description="Application version")
    description: str = Field(default="Enterprise Security Solution", description="Project description")

    # Environment
    environment: str = Field(default="development", description="Environment (development/production)")
    debug: bool = Field(default=False, description="Debug mode")

    # Database Configuration
    mongodb_url: str = Field(default="mongodb://localhost:27017", description="MongoDB connection URL")
    database_name: str = Field(default="kobi_firewall_db", description="Database name")

    # JWT Configuration
    jwt_secret: str = Field(default="change-this-secret-key-in-production-please-make-it-longer-than-32-chars", description="JWT secret key")
    jwt_algorithm: str = Field(default="HS256", description="JWT algorithm")
    access_token_expire_minutes: int = Field(default=480, description="Token expiration in minutes")

    # CORS Configuration - This will handle both string and list input
    cors_origins: Union[str, List[str]] = Field(
        default="http://localhost:3000,http://localhost:5173",
        description="Allowed CORS origins"
    )

    # Security Settings
    rate_limit_requests_per_minute: int = Field(default=100, description="Rate limit per minute")
    max_upload_size_mb: int = Field(default=10, description="Maximum upload size in MB")

    # Logging Configuration
    log_level: str = Field(default="INFO", description="Logging level")
    log_format: str = Field(default="detailed", description="Log format (simple/detailed)")

    # Network Settings
    default_dns_servers: Union[str, List[str]] = Field(
        default="8.8.8.8,8.8.4.4",
        description="Default DNS servers"
    )

    # Firewall Settings
    max_firewall_rules: int = Field(default=1000, description="Maximum number of firewall rules")
    rule_backup_enabled: bool = Field(default=True, description="Enable automatic rule backup")

    # Backward compatibility properties
    @property
    def MONGODB_URL(self) -> str:
        """Backward compatibility for MONGODB_URL"""
        return self.mongodb_url

    @property
    def DATABASE_NAME(self) -> str:
        """Backward compatibility for DATABASE_NAME"""
        return self.database_name

    @field_validator('cors_origins', mode='before')
    @classmethod
    def parse_cors_origins(cls, v):
        """Parse CORS origins from string or list"""
        if isinstance(v, str):
            return [origin.strip() for origin in v.split(',') if origin.strip()]
        elif isinstance(v, list):
            return v
        return ["http://localhost:3000", "http://localhost:5173"]

    @field_validator('default_dns_servers', mode='before')
    @classmethod
    def parse_dns_servers(cls, v):
        """Parse DNS servers from string or list"""
        if isinstance(v, str):
            return [server.strip() for server in v.split(',') if server.strip()]
        elif isinstance(v, list):
            return v
        return ["8.8.8.8", "8.8.4.4"]

    @field_validator('jwt_secret')
    @classmethod
    def validate_jwt_secret(cls, v):
        """Validate JWT secret strength"""
        if len(v) < 32:
            raise ValueError('JWT secret must be at least 32 characters long')
        return v

    @field_validator('environment')
    @classmethod
    def validate_environment(cls, v):
        """Validate environment values"""
        allowed_envs = ['development', 'staging', 'production']
        if v not in allowed_envs:
            raise ValueError(f'Environment must be one of: {allowed_envs}')
        return v

    @property
    def is_production(self) -> bool:
        """Check if running in production"""
        return self.environment == "production"

    @property
    def is_development(self) -> bool:
        """Check if running in development"""
        return self.environment == "development"

    @property
    def database_url(self) -> str:
        """Get complete database URL"""
        return f"{self.mongodb_url}/{self.database_name}"

@lru_cache()
def get_settings() -> Settings:
    """Get cached settings instance"""
    return Settings()

# Export settings instance
settings = get_settings()


================================================
File: app/win_firewall.py
================================================
# File: app/win_firewall.py

import subprocess
from fastapi import HTTPException
from app.firewall_driver import FirewallDriver

class WinFirewall(FirewallDriver):
    def add_rule(self, rule):
        """
        Windows PowerShell kullanarak firewall kuralı ekler.
        Birden fazla port veya ANY protokol desteğini ekledik.
        """

        # Action: ALLOW veya DENY -> PS karşılığı "Allow" veya "Block"
        ps_action = "Allow" if rule.get("action", "").upper() == "ALLOW" else "Block"

        # Yön: IN / OUT -> PS karşılığı "Inbound" / "Outbound"
        direction_map = {"IN": "Inbound", "OUT": "Outbound"}
        ps_dir = direction_map.get(rule.get("direction", "").upper(), "Inbound")

        # Kural ismi
        rule_name = rule.get("rule_name", "UnnamedRule")

        # Komutu oluştur
        cmd = f"New-NetFirewallRule -Name '{rule_name}' -DisplayName '{rule_name}'"
        cmd += f" -Direction {ps_dir} -Action {ps_action}"

        # Protokol: TCP / UDP / ANY
        # -Protocol ANY, Windows'ta çalışır (bazı versiyonlarda ANY verince “All” sayılır).
        protocol = rule.get("protocol", "ANY").upper()
        if protocol != "ANY":
            cmd += f" -Protocol {protocol}"
        else:
            # ANY seçilince -Protocol ANY diyebiliriz.
            cmd += " -Protocol ANY"

        # Port bilgisi (birden fazla port girilmiş olabilir, örn: "80,443")
        # AMA "ANY" protokol seçildiyse, Windows'ta port parametresi genelde geçersizdir.
        port_str = rule.get("port")
        if port_str and protocol != "ANY":
            # Kullanıcı virgülle ayırmış olabilir (ör: "80,443").
            # Aradaki boşlukları silelim:
            port_str = str(port_str).replace(" ", "")
            if ps_dir == "Inbound":
                cmd += f" -LocalPort {port_str}"
            else:
                cmd += f" -RemotePort {port_str}"
            # Eğer range girilecekse ("80-90") da bu şekilde geçerli olur.

        # Source IP adres(ler)i (ör: ["10.36.130.28"])
        source_ips = rule.get("source_ips", [])
        if source_ips:
            # virgülle birleştirelim
            ip_list = ",".join(source_ips)
            cmd += f" -RemoteAddress {ip_list}"

        # Profile: "Any" / "Domain" / "Private" / "Public"
        # eğer "Any" girilmişse parametre eklemeye gerek yok diyebiliriz. (Ama biz yine de ekleyebiliriz)
        profile_val = rule.get("profile", "Any")
        if profile_val.lower() != "any":
            # ilk harfi büyük geri kalanı küçük
            cmd += f" -Profile {profile_val.capitalize()}"

        # Açıklama varsa
        description = rule.get("description")
        if description:
            cmd += f" -Description '{description}'"

        # PowerShell komutunu çalıştıralım
        ps_cmd = ["powershell", "-Command", cmd]
        res = subprocess.run(ps_cmd, capture_output=True, text=True)

        if res.returncode != 0:
            # Windows firewall komutundan gelen stderr'i kullanıcıya gösteriyoruz
            error_msg = res.stderr.strip()
            raise HTTPException(400, f"Windows firewall add rule error: {error_msg}")

        # Kural eklendikten sonra "enabled": false ise devre dışı bırakalım
        if rule.get("enabled", True) is False:
            dc_cmd = [
                "powershell",
                "-Command",
                f"Disable-NetFirewallRule -Name '{rule_name}'"
            ]
            subprocess.run(dc_cmd, capture_output=True, text=True)

    def remove_rule(self, rule_name):
        """
        Kuralı isme göre siler.
        """
        ps_cmd = ["powershell", "-Command", f"Remove-NetFirewallRule -Name '{rule_name}'"]
        subprocess.run(ps_cmd, capture_output=True, text=True)

    def update_rule(self, old_rule, new_rule):
        """
        Önce eski kuralı silip sonra yenisini ekliyoruz.
        """
        self.remove_rule(old_rule.get("rule_name", ""))
        self.add_rule(new_rule)




================================================
File: app/routers/__init__.py
================================================
"""
KOBI Firewall System Routers
"""

# Router modules
from . import auth
from . import firewall
from . import logs
from . import system
from . import network
from . import routes
from . import dns
from . import nat
from . import backup
from . import firewall_groups
from . import status
from . import settings_router

# Optional routers (may not exist)
try:
    from . import reports
except ImportError:
    pass

__all__ = [
    "auth",
    "firewall",
    "logs",
    "system",
    "network",
    "routes",
    "dns",
    "nat",
    "backup",
    "firewall_groups",
    "status",
    "settings_router"
]


================================================
File: app/routers/auth.py
================================================
from fastapi import APIRouter, HTTPException, status, Request
from pydantic import BaseModel
from typing import Optional
from datetime import datetime, timedelta
import hashlib
import logging

# JWT paketini doÄŸru import
try:
    import jwt  # PyJWT paketi 'jwt' olarak import edilir

    JWT_AVAILABLE = True
    print("JWT imported successfully")
except ImportError:
    try:
        import PyJWT as jwt  # Alternatif import

        JWT_AVAILABLE = True
        print("PyJWT imported as jwt")
    except ImportError:
        JWT_AVAILABLE = False
        print("JWT not available")

from ..database import get_database
from ..config import get_settings

# Logger
logger = logging.getLogger(__name__)


# Models
class LoginRequest(BaseModel):
    username: str
    password: str
    remember_me: Optional[bool] = False


class LoginResponse(BaseModel):
    access_token: str
    token_type: str
    user: dict


# Router
router = APIRouter(prefix="/api/v1/auth", tags=["Authentication"])
settings = get_settings()


def hash_password(password: str) -> str:
    """Hash password using SHA-256"""
    return hashlib.sha256(password.encode()).hexdigest()


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify password against hash"""
    return hash_password(plain_password) == hashed_password


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Create JWT access token"""
    if not JWT_AVAILABLE:
        # Simple token without JWT
        import time
        return f"simple_token_{data.get('username', 'user')}_{int(time.time())}"

    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(hours=24)

    to_encode.update({"exp": expire})
    try:
        encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm="HS256")
        return encoded_jwt
    except Exception as e:
        logger.warning(f"JWT encode failed: {e}, using simple token")
        import time
        return f"simple_token_{data.get('username', 'user')}_{int(time.time())}"


@router.post("/login", response_model=LoginResponse)
async def login_user(request: LoginRequest, client_request: Request):
    """Authenticate user and return JWT token"""
    try:
        client_ip = client_request.client.host
        logger.info(f"Login attempt from {client_ip}: {request.username}")

        db = await get_database()
        users_collection = db.users

        # Find user by username
        user = await users_collection.find_one({"username": request.username})

        if not user:
            logger.warning(f"User not found: {request.username}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid username or password"
            )

        # Verify password
        if not verify_password(request.password, user["password"]):
            logger.warning(f"Invalid password for user: {request.username}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid username or password"
            )

        logger.info(f"Login successful for user: {request.username}")

        # Update last login
        await users_collection.update_one(
            {"_id": user["_id"]},
            {"$set": {"last_login": datetime.utcnow()}}
        )

        # Create access token
        access_token_expires = timedelta(hours=24 if request.remember_me else 8)
        access_token = create_access_token(
            data={"sub": str(user["_id"]), "username": user["username"]},
            expires_delta=access_token_expires
        )

        # Prepare user data for response - safe defaults
        user_data = {
            "id": str(user["_id"]),
            "username": user["username"],
            "email": user.get("email", ""),
            "full_name": user.get("full_name", ""),
            "is_active": user.get("is_active", True),
            "created_at": user.get("created_at", datetime.utcnow()).isoformat() if isinstance(user.get("created_at"),
                                                                                              datetime) else str(
                user.get("created_at", datetime.utcnow())),
            "last_login": user.get("last_login", datetime.utcnow()).isoformat() if isinstance(user.get("last_login"),
                                                                                              datetime) else str(
                user.get("last_login")) if user.get("last_login") else None
        }

        return LoginResponse(
            access_token=access_token,
            token_type="bearer",
            user=user_data
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Login error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during login"
        )


@router.post("/logout")
async def logout_user():
    """Logout user"""
    return {"message": "Successfully logged out"}


@router.get("/health")
async def auth_health():
    """Auth service health check"""
    return {
        "status": "healthy",
        "service": "Auth",
        "jwt_available": JWT_AVAILABLE,
        "timestamp": datetime.utcnow().isoformat()
    }


================================================
File: app/routers/auth_simple.py
================================================
from fastapi import APIRouter, HTTPException, status, Request
from pydantic import BaseModel
from typing import Optional
from datetime import datetime, timedelta
import hashlib
import logging
import time
import secrets

from ..database import get_database
from ..config import get_settings

# Logger
logger = logging.getLogger(__name__)


# Models
class LoginRequest(BaseModel):
    username: str
    password: str
    remember_me: Optional[bool] = False


class LoginResponse(BaseModel):
    access_token: str
    token_type: str
    user: dict


# Router
router = APIRouter(prefix="/api/v1/auth", tags=["Authentication"])
settings = get_settings()


def hash_password(password: str) -> str:
    """Hash password using SHA-256"""
    return hashlib.sha256(password.encode()).hexdigest()


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify password against hash"""
    return hash_password(plain_password) == hashed_password


def create_simple_token(username: str) -> str:
    """Create simple token without JWT"""
    timestamp = int(time.time())
    random_part = secrets.token_hex(16)
    return f"token_{username}_{timestamp}_{random_part}"


@router.post("/login", response_model=LoginResponse)
async def login_user(request: LoginRequest, client_request: Request):
    """Authenticate user and return simple token"""
    try:
        client_ip = client_request.client.host
        logger.info(f"Login attempt from {client_ip}: {request.username}")

        db = await get_database()
        users_collection = db.users

        # Find user by username
        user = await users_collection.find_one({"username": request.username})

        if not user:
            logger.warning(f"User not found: {request.username}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid username or password"
            )

        logger.info(f"User found: {user}")

        # Check if password field exists
        if "password" not in user:
            logger.error(f"Password field missing for user: {request.username}")
            # Create admin with correct password if it's admin user
            if request.username == "admin":
                hashed_password = hash_password("admin123")
                await users_collection.update_one(
                    {"username": "admin"},
                    {"$set": {"password": hashed_password}}
                )
                logger.info("Admin password updated")
                # Reload user
                user = await users_collection.find_one({"username": request.username})
            else:
                raise HTTPException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    detail="User password not configured"
                )

        # Verify password
        if not verify_password(request.password, user["password"]):
            logger.warning(f"Invalid password for user: {request.username}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid username or password"
            )

        logger.info(f"Login successful for user: {request.username}")

        # Update last login
        await users_collection.update_one(
            {"_id": user["_id"]},
            {"$set": {"last_login": datetime.utcnow()}}
        )

        # Create simple access token
        access_token = create_simple_token(user["username"])

        # Prepare user data for response - safe defaults
        user_data = {
            "id": str(user["_id"]),
            "username": user["username"],
            "email": user.get("email", "admin@netgate.local"),
            "full_name": user.get("full_name", "System Administrator"),
            "is_active": user.get("is_active", True),
            "created_at": user.get("created_at", datetime.utcnow()).isoformat() if isinstance(user.get("created_at"),
                                                                                              datetime) else str(
                user.get("created_at", datetime.utcnow())),
            "last_login": datetime.utcnow().isoformat()
        }

        return LoginResponse(
            access_token=access_token,
            token_type="bearer",
            user=user_data
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Login error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error during login: {str(e)}"
        )


@router.post("/logout")
async def logout_user():
    """Logout user"""
    return {"message": "Successfully logged out"}


@router.get("/health")
async def auth_health():
    """Auth service health check"""
    return {
        "status": "healthy",
        "service": "Auth (Simple)",
        "jwt_available": False,
        "timestamp": datetime.utcnow().isoformat()
    }


@router.post("/fix-admin")
async def fix_admin_user():
    """Fix admin user password"""
    try:
        db = await get_database()
        users_collection = db.users

        # Update admin user with proper password
        hashed_password = hash_password("admin123")
        result = await users_collection.update_one(
            {"username": "admin"},
            {"$set": {
                "password": hashed_password,
                "email": "admin@netgate.local",
                "full_name": "System Administrator",
                "is_active": True,
                "created_at": datetime.utcnow()
            }},
            upsert=True
        )

        return {
            "success": True,
            "message": "Admin user fixed",
            "modified": result.modified_count,
            "upserted": result.upserted_id is not None
        }

    except Exception as e:
        logger.error(f"Fix admin error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to fix admin user: {str(e)}"
        )


================================================
File: app/routers/backup.py
================================================
from fastapi import APIRouter

router = APIRouter(prefix="/api/v1/backup", tags=["Backup"])

@router.post("/create")
async def create_backup():
    """Create system backup"""
    return {
        "success": True,
        "message": "Backup created successfully"
    }


================================================
File: app/routers/dns.py
================================================
from fastapi import APIRouter

router = APIRouter(prefix="/api/v1/dns", tags=["DNS"])

@router.get("/")
async def get_dns_settings():
    """Get DNS settings"""
    return {
        "success": True,
        "data": {
            "primary": "8.8.8.8",
            "secondary": "8.8.4.4"
        }
    }


================================================
File: app/routers/firewall.py
================================================
from fastapi import APIRouter, HTTPException
from typing import List, Optional
from datetime import datetime

router = APIRouter(prefix="/api/v1/firewall", tags=["Firewall"])

@router.get("/")
async def get_firewall_status():
    """Get firewall status"""
    return {
        "success": True,
        "status": "active",
        "rules_count": 0,
        "timestamp": datetime.utcnow().isoformat()
    }

@router.get("/rules")
async def get_firewall_rules():
    """Get firewall rules"""
    return {
        "success": True,
        "data": [],
        "total": 0
    }


================================================
File: app/routers/firewall_groups.py
================================================
from fastapi import APIRouter

router = APIRouter(prefix="/api/v1/firewall-groups", tags=["Firewall Groups"])

@router.get("/")
async def get_firewall_groups():
    """Get firewall groups"""
    return {
        "success": True,
        "data": []
    }


================================================
File: app/routers/layer7_inspect.py
================================================
import threading
from scapy.all import sniff, TCP

def packet_callback(pkt):
    if pkt.haslayer(TCP):
        payload = bytes(pkt[TCP].payload)
        # Ã–rnek: HTTP flood tespiti, SSH brute force vs.
        # Uygun bulursak DB'ye log, firewall rule ekleme vs.

def start_sniffer():
    sniff(filter="tcp", prn=packet_callback, store=0)

def start_layer7_inspect():
    t = threading.Thread(target=start_sniffer, daemon=True)
    t.start()



================================================
File: app/routers/logs.py
================================================
from fastapi import APIRouter
from datetime import datetime

router = APIRouter(prefix="/api/v1/logs", tags=["Logs"])

@router.get("/")
async def get_logs():
    """Get system logs"""
    return {
        "success": True,
        "data": [],
        "total": 0,
        "timestamp": datetime.utcnow().isoformat()
    }


================================================
File: app/routers/nat.py
================================================
from fastapi import APIRouter

router = APIRouter(prefix="/api/v1/nat", tags=["NAT"])

@router.get("/")
async def get_nat_config():
    """Get NAT configuration"""
    return {
        "success": True,
        "data": {
            "enabled": False,
            "wan_interface": "",
            "lan_interface": ""
        }
    }

@router.patch("/")
async def update_nat_config(config: dict):
    """Update NAT configuration"""
    return {
        "success": True,
        "message": "NAT configuration updated"
    }


================================================
File: app/routers/network.py
================================================
from fastapi import APIRouter
from datetime import datetime

router = APIRouter(prefix="/api/v1/network", tags=["Network"])

@router.get("/interfaces")
async def get_network_interfaces():
    """Get network interfaces"""
    return {
        "success": True,
        "data": [
            {"name": "Ethernet", "displayName": "Ethernet", "description": "Yerel Alan BaÄŸlantÄ±sÄ±"},
            {"name": "Wi-Fi", "displayName": "Wi-Fi", "description": "Kablosuz AÄŸ BaÄŸdaÅŸtÄ±rÄ±cÄ±sÄ±"},
            {"name": "Ethernet 2", "displayName": "Ethernet 2", "description": "USB-Ethernet AdaptÃ¶rÃ¼"}
        ]
    }


================================================
File: app/routers/reports.py
================================================
from fastapi import APIRouter
from datetime import datetime

router = APIRouter(prefix="/api/v1/reports", tags=["Reports"])

@router.get("/data")
async def get_reports_data(filter: str = "Son 30 gÃ¼n"):
    """Get reports data"""
    return {
        "success": True,
        "data": {
            "totalTraffic": "2.4 TB",
            "trafficGrowth": "+12",
            "systemAttempts": "34",
            "attemptsGrowth": "-8",
            "blockedRequests": "1,247",
            "blockedGrowth": "+3",
            "systemUptime": "15 gÃ¼n 6 saat",
            "uptimePercentage": "99.8",
            "securityReport": {
                "attackAttempts": 34,
                "blockedIPs": 12,
                "topAttackedPorts": [
                    {"port": "22", "service": "SSH", "attempts": 156},
                    {"port": "80", "service": "HTTP", "attempts": 89},
                    {"port": "443", "service": "HTTPS", "attempts": 34}
                ]
            },
            "quickStats": {
                "dailyAverageTraffic": "80 GB",
                "peakHour": "14:00-15:00",
                "averageResponseTime": "12ms",
                "successRate": "99.2%",
                "securityScore": "8.7/10"
            },
            "lastUpdate": "19.06.2025 10:30"
        }
    }

@router.post("/export")
async def export_report(data: dict):
    """Export report"""
    return {
        "success": True,
        "message": "Report exported successfully"
    }


================================================
File: app/routers/routes.py
================================================
from fastapi import APIRouter

router = APIRouter(prefix="/api/v1/routes", tags=["Routes"])

@router.get("/")
async def get_routes():
    """Get network routes"""
    return {
        "success": True,
        "data": []
    }


================================================
File: app/routers/settings.py
================================================
"""
Settings router for system configuration management
"""
import psutil
import platform
import subprocess
from datetime import datetime, timedelta
from typing import Dict, Any, Optional
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from pydantic import BaseModel
from ..database import get_database
from ..dependencies import get_current_user, require_admin
from ..schemas import ResponseModel

settings_router = APIRouter()


# Settings Models
class GeneralSettings(BaseModel):
    timezone: str
    language: str
    sessionTimeout: int
    logLevel: str


class AutoUpdateSettings(BaseModel):
    enabled: bool
    frequency: str
    time: str


class SystemFeedbackSettings(BaseModel):
    enabled: bool
    errorReporting: bool
    analytics: bool


class DarkThemeSettings(BaseModel):
    enabled: bool
    autoSwitch: bool


class BackupSettings(BaseModel):
    frequency: str
    location: str
    retention: int
    autoCleanup: bool


@settings_router.get("")
async def get_settings(
        current_user=Depends(get_current_user),
        db=Depends(get_database)
):
    """Get all system settings"""
    try:
        # Get settings from database
        settings_doc = await db.system_config.find_one({"_id": "settings"}) or {}

        # Get system info
        cpu_percent = psutil.cpu_percent(interval=0.1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        uptime = psutil.boot_time()
        uptime_seconds = int(datetime.utcnow().timestamp() - uptime)

        # Default settings
        default_settings = {
            "general": {
                "timezone": "Europe/Istanbul",
                "language": "tr",
                "sessionTimeout": 480,
                "logLevel": "INFO"
            },
            "autoUpdates": {
                "enabled": True,
                "frequency": "daily",
                "time": "02:00"
            },
            "systemFeedback": {
                "enabled": True,
                "errorReporting": True,
                "analytics": False
            },
            "darkTheme": {
                "enabled": True,
                "autoSwitch": False
            },
            "backup": {
                "frequency": "weekly",
                "location": "/opt/netgate/backups",
                "retention": 30,
                "autoCleanup": True
            },
            "systemInfo": {
                "version": "2.1.0",
                "uptime": uptime_seconds,
                "memoryUsage": memory.percent,
                "diskUsage": (disk.used / disk.total) * 100
            },
            "security": {
                "firewall": True,
                "ssl": True,
                "lastSecurityScan": datetime.utcnow().isoformat()
            }
        }

        # Merge with saved settings
        saved_settings = settings_doc.get("settings", {})
        for section in default_settings:
            if section in saved_settings:
                default_settings[section].update(saved_settings[section])

        return {
            "success": True,
            "data": default_settings
        }
    except Exception as e:
        raise HTTPException(500, f"Failed to get settings: {str(e)}")


@settings_router.patch("/{section}")
async def update_settings_section(
        section: str,
        settings_data: Dict[str, Any],
        current_user=Depends(require_admin),
        db=Depends(get_database)
):
    """Update specific settings section"""
    try:
        # Update settings in database
        await db.system_config.update_one(
            {"_id": "settings"},
            {
                "$set": {
                    f"settings.{section}": settings_data,
                    "updated_at": datetime.utcnow(),
                    "updated_by": str(current_user["_id"])
                }
            },
            upsert=True
        )

        # Log the change
        await db.system_logs.insert_one({
            "timestamp": datetime.utcnow(),
            "level": "INFO",
            "source": "settings",
            "message": f"Settings section updated: {section}",
            "user_id": str(current_user["_id"]),
            "section": section,
            "data": settings_data
        })

        return ResponseModel(
            message=f"{section} ayarları başarıyla güncellendi",
            details={"section": section, "data": settings_data}
        )
    except Exception as e:
        raise HTTPException(500, f"Settings update failed: {str(e)}")


@settings_router.post("/restart")
async def restart_system(
        background_tasks: BackgroundTasks,
        current_user=Depends(require_admin),
        db=Depends(get_database)
):
    """Restart the system"""
    try:
        # Log restart request
        await db.system_logs.insert_one({
            "timestamp": datetime.utcnow(),
            "level": "WARNING",
            "source": "system",
            "message": f"System restart requested by {current_user['username']}",
            "user_id": str(current_user["_id"])
        })

        # Schedule restart (in a real system, implement actual restart logic)
        background_tasks.add_task(simulate_system_restart)

        return ResponseModel(
            message="Sistem yeniden başlatılıyor... 3 saniye sonra bağlantı kesilecek"
        )
    except Exception as e:
        raise HTTPException(500, f"System restart failed: {str(e)}")


@settings_router.post("/backup")
async def create_manual_backup(
        background_tasks: BackgroundTasks,
        current_user=Depends(require_admin),
        db=Depends(get_database)
):
    """Create manual backup"""
    try:
        # Start backup process
        background_tasks.add_task(perform_system_backup, str(current_user["_id"]), db)

        return ResponseModel(
            message="Manuel yedekleme başlatıldı"
        )
    except Exception as e:
        raise HTTPException(500, f"Backup creation failed: {str(e)}")


@settings_router.delete("/logs")
async def clear_system_logs(
        current_user=Depends(require_admin),
        db=Depends(get_database)
):
    """Clear system logs"""
    try:
        # Count logs before deletion
        total_logs = await db.system_logs.count_documents({})

        # Keep last 100 critical logs
        critical_logs = db.system_logs.find({"level": "ERROR"}).sort("timestamp", -1).limit(100)
        critical_log_ids = []
        async for log in critical_logs:
            critical_log_ids.append(log["_id"])

        # Delete all logs except critical ones
        result = await db.system_logs.delete_many({
            "_id": {"$nin": critical_log_ids}
        })

        # Log the action
        await db.system_logs.insert_one({
            "timestamp": datetime.utcnow(),
            "level": "WARNING",
            "source": "settings",
            "message": f"System logs cleared by {current_user['username']} - {result.deleted_count} logs deleted",
            "user_id": str(current_user["_id"]),
            "deleted_count": result.deleted_count
        })

        return ResponseModel(
            message=f"Sistem logları temizlendi - {result.deleted_count} log silindi",
            details={"deleted_count": result.deleted_count, "kept_critical": len(critical_log_ids)}
        )
    except Exception as e:
        raise HTTPException(500, f"Log clearing failed: {str(e)}")


async def simulate_system_restart():
    """Simulate system restart process"""
    import asyncio
    await asyncio.sleep(3)
    print("🔄 System restart simulation completed")


async def perform_system_backup(user_id: str, db):
    """Perform system backup"""
    try:
        # Simulate backup process
        import asyncio
        await asyncio.sleep(5)

        # Log backup completion
        await db.system_logs.insert_one({
            "timestamp": datetime.utcnow(),
            "level": "INFO",
            "source": "backup",
            "message": "Manual backup completed successfully",
            "user_id": user_id,
            "backup_size": "45.2 MB",
            "backup_location": "/opt/netgate/backups/"
        })

        print("✅ Manual backup completed")
    except Exception as e:
        await db.system_logs.insert_one({
            "timestamp": datetime.utcnow(),
            "level": "ERROR",
            "source": "backup",
            "message": f"Manual backup failed: {str(e)}",
            "user_id": user_id
        })
        print(f"❌ Manual backup failed: {e}")


================================================
File: app/routers/settings_router.py
================================================
from fastapi import APIRouter

router = APIRouter(prefix="/api/v1/settings", tags=["Settings"])

@router.get("/")
async def get_settings():
    """Get system settings"""
    return {
        "success": True,
        "data": {
            "timezone": "TÃ¼rkiye (UTC+3)",
            "language": "TÃ¼rkÃ§e",
            "session_timeout": 60
        }
    }

@router.patch("/{section}")
async def update_settings(section: str, data: dict):
    """Update settings section"""
    return {
        "success": True,
        "message": f"Settings section '{section}' updated successfully"
    }


================================================
File: app/routers/status.py
================================================
from fastapi import APIRouter
from datetime import datetime

router = APIRouter(prefix="/api/v1/status", tags=["Status"])

@router.get("/")
async def get_system_status():
    """Get system status"""
    return {
        "success": True,
        "data": {
            "firewall": "active",
            "database": "connected",
            "last_update": datetime.utcnow().isoformat()
        }
    }


================================================
File: app/routers/system.py
================================================
from fastapi import APIRouter
from datetime import datetime

router = APIRouter(prefix="/api/v1/system", tags=["System"])

@router.get("/info")
async def get_system_info():
    """Get system information"""
    return {
        "success": True,
        "data": {
            "version": "2.0.0",
            "uptime": "0 days",
            "memory_usage": "25%",
            "disk_usage": "45%"
        },
        "timestamp": datetime.utcnow().isoformat()
    }

@router.get("/updates")
async def get_updates():
    """Get system updates"""
    return {
        "success": True,
        "data": {
            "currentVersion": "2.1.0",
            "lastCheck": "19.06.2025 10:30",
            "checkMethod": "Otomatik",
            "pendingUpdates": 0,
            "updateStatus": "GÃ¼ncel",
            "updateSettings": {
                "autoUpdate": True,
                "checkFrequency": "daily",
                "autoInstallTime": "02:00"
            },
            "availableUpdates": [],
            "systemInfo": {
                "product": "NetGate Firewall",
                "currentVersion": "2.1.0",
                "latestVersion": "2.1.2",
                "buildDate": "2025.06.19",
                "license": "Pro"
            },
            "updateHistory": []
        }
    }

@router.post("/updates/check")
async def check_updates():
    """Check for updates"""
    return {
        "success": True,
        "message": "Update check completed"
    }

@router.post("/updates/{update_id}/install")
async def install_update(update_id: str):
    """Install specific update"""
    return {
        "success": True,
        "message": f"Update {update_id} installed successfully"
    }

@router.patch("/updates/settings")
async def update_settings(settings: dict):
    """Update system settings"""
    return {
        "success": True,
        "message": "Settings updated successfully"
    }



================================================
File: app/services/firewall_service.py
================================================
"""
Firewall service layer with business logic and validation
"""

import ipaddress
import re
from typing import Dict, Any, List
from fastapi import HTTPException, status


class FirewallService:
    """Service class for firewall rule management"""

    def __init__(self):
        self.valid_protocols = ["TCP", "UDP", "ICMP", "ANY"]
        self.valid_actions = ["ALLOW", "DENY", "DROP", "REJECT"]
        self.valid_directions = ["IN", "OUT", "BOTH"]
        self.valid_profiles = ["Any", "Domain", "Private", "Public"]

    async def validate_rule_data(self, rule_data: Dict[str, Any]) -> None:
        """Validate firewall rule data"""

        # Validate required fields
        if not rule_data.get("rule_name"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Rule name is required"
            )

        # Validate rule name format
        if not re.match(r'^[a-zA-Z0-9_\-\s]+$', rule_data["rule_name"]):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Rule name contains invalid characters"
            )

        # Validate protocol
        if rule_data.get("protocol") and rule_data["protocol"] not in self.valid_protocols:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid protocol. Must be one of: {', '.join(self.valid_protocols)}"
            )

        # Validate action
        if rule_data.get("action") and rule_data["action"] not in self.valid_actions:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid action. Must be one of: {', '.join(self.valid_actions)}"
            )

        # Validate direction
        if rule_data.get("direction") and rule_data["direction"] not in self.valid_directions:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid direction. Must be one of: {', '.join(self.valid_directions)}"
            )

        # Validate profile
        if rule_data.get("profile") and rule_data["profile"] not in self.valid_profiles:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid profile. Must be one of: {', '.join(self.valid_profiles)}"
            )

        # Validate IP addresses
        for ip_field in ["source_ips", "destination_ips"]:
            if rule_data.get(ip_field):
                self._validate_ip_list(rule_data[ip_field], ip_field)

        # Validate ports
        for port_field in ["source_ports", "destination_ports"]:
            if rule_data.get(port_field):
                self._validate_port_list(rule_data[port_field], port_field)

        # Validate priority
        if rule_data.get("priority"):
            priority = rule_data["priority"]
            if not isinstance(priority, int) or priority < 1 or priority > 1000:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Priority must be an integer between 1 and 1000"
                )

        # Validate schedule
        if rule_data.get("schedule_start") or rule_data.get("schedule_end"):
            self._validate_schedule(rule_data)

        # Validate days of week
        if rule_data.get("days_of_week"):
            self._validate_days_of_week(rule_data["days_of_week"])

    def _validate_ip_list(self, ip_list: List[str], field_name: str) -> None:
        """Validate list of IP addresses or networks"""
        if not isinstance(ip_list, list):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"{field_name} must be a list"
            )

        for ip_str in ip_list:
            try:
                # Try to parse as IP network (supports CIDR notation)
                ipaddress.ip_network(ip_str, strict=False)
            except ValueError:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Invalid IP address or network in {field_name}: {ip_str}"
                )

    def _validate_port_list(self, port_list: List[str], field_name: str) -> None:
        """Validate list of ports or port ranges"""
        if not isinstance(port_list, list):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"{field_name} must be a list"
            )

        for port_str in port_list:
            if not isinstance(port_str, str):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Port values in {field_name} must be strings"
                )

            # Check for port range (e.g., "80-443")
            if "-" in port_str:
                try:
                    start_port, end_port = port_str.split("-", 1)
                    start_port = int(start_port.strip())
                    end_port = int(end_port.strip())

                    if not (1 <= start_port <= 65535) or not (1 <= end_port <= 65535):
                        raise ValueError()

                    if start_port >= end_port:
                        raise ValueError("Invalid port range")

                except ValueError:
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail=f"Invalid port range in {field_name}: {port_str}"
                    )
            else:
                # Single port
                try:
                    port = int(port_str.strip())
                    if not (1 <= port <= 65535):
                        raise ValueError()
                except ValueError:
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail=f"Invalid port in {field_name}: {port_str}"
                    )

    def _validate_schedule(self, rule_data: Dict[str, Any]) -> None:
        """Validate schedule configuration"""
        schedule_start = rule_data.get("schedule_start")
        schedule_end = rule_data.get("schedule_end")

        time_pattern = re.compile(r'^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$')

        if schedule_start and not time_pattern.match(schedule_start):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid schedule start time format. Use HH:MM"
            )

        if schedule_end and not time_pattern.match(schedule_end):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid schedule end time format. Use HH:MM"
            )

        # If both times are provided, validate the range
        if schedule_start and schedule_end:
            start_minutes = self._time_to_minutes(schedule_start)
            end_minutes = self._time_to_minutes(schedule_end)

            if start_minutes >= end_minutes:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Schedule start time must be before end time"
                )

    def _validate_days_of_week(self, days: List[int]) -> None:
        """Validate days of week list"""
        if not isinstance(days, list):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Days of week must be a list"
            )

        for day in days:
            if not isinstance(day, int) or day < 0 or day > 6:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Days of week must be integers between 0 (Monday) and 6 (Sunday)"
                )

    def _time_to_minutes(self, time_str: str) -> int:
        """Convert time string (HH:MM) to minutes since midnight"""
        hours, minutes = map(int, time_str.split(':'))
        return hours * 60 + minutes

    def format_rule_for_os(self, rule_data: Dict[str, Any]) -> Dict[str, Any]:
        """Format rule data for operating system firewall"""

        formatted_rule = {
            "rule_name": rule_data.get("rule_name", ""),
            "action": rule_data.get("action", "ALLOW"),
            "direction": rule_data.get("direction", "IN"),
            "protocol": rule_data.get("protocol", "ANY"),
            "enabled": rule_data.get("enabled", True),
            "priority": rule_data.get("priority", 100),
            "description": rule_data.get("description", "")
        }

        # Format IP addresses
        if rule_data.get("source_ips"):
            formatted_rule["source_ips"] = rule_data["source_ips"]

        if rule_data.get("destination_ips"):
            formatted_rule["destination_ips"] = rule_data["destination_ips"]

        # Format ports
        if rule_data.get("source_ports"):
            formatted_rule["source_ports"] = ",".join(rule_data["source_ports"])

        if rule_data.get("destination_ports"):
            formatted_rule["destination_ports"] = ",".join(rule_data["destination_ports"])

        # Add schedule if present
        if rule_data.get("schedule_start") and rule_data.get("schedule_end"):
            formatted_rule["schedule_start"] = rule_data["schedule_start"]
            formatted_rule["schedule_end"] = rule_data["schedule_end"]

            if rule_data.get("days_of_week"):
                formatted_rule["days_of_week"] = rule_data["days_of_week"]

        return formatted_rule

    def check_rule_conflicts(self, rule_data: Dict[str, Any], existing_rules: List[Dict[str, Any]]) -> List[str]:
        """Check for potential conflicts with existing rules"""
        conflicts = []

        # Check for exact duplicates
        for existing_rule in existing_rules:
            if self._rules_overlap(rule_data, existing_rule):
                conflicts.append(f"Rule overlaps with existing rule: {existing_rule.get('rule_name', 'Unknown')}")

        return conflicts

    def _rules_overlap(self, rule1: Dict[str, Any], rule2: Dict[str, Any]) -> bool:
        """Check if two rules overlap in their network scope"""
        # This is a simplified check - in production, you'd want more sophisticated overlap detection

        # Check if protocols overlap
        proto1 = rule1.get("protocol", "ANY")
        proto2 = rule2.get("protocol", "ANY")

        if proto1 != "ANY" and proto2 != "ANY" and proto1 != proto2:
            return False

        # Check if directions overlap
        dir1 = rule1.get("direction", "IN")
        dir2 = rule2.get("direction", "IN")

        if dir1 != dir2 and "BOTH" not in [dir1, dir2]:
            return False

        # Check IP address overlap (simplified)
        src_ips1 = rule1.get("source_ips", ["0.0.0.0/0"])
        src_ips2 = rule2.get("source_ips", ["0.0.0.0/0"])

        # If both rules have any-source or overlap in source IPs
        if "0.0.0.0/0" in src_ips1 or "0.0.0.0/0" in src_ips2:
            return True

        # Check for actual IP overlap (simplified - check if any IPs are the same)
        for ip1 in src_ips1:
            for ip2 in src_ips2:
                if ip1 == ip2:
                    return True

        return False



================================================
File: app/tasks/__init__.py
================================================
"""
Background tasks module for KOBI Firewall
"""


================================================
File: app/tasks/cleanup.py
================================================
"""
Database cleanup and maintenance tasks
"""
import asyncio
from datetime import datetime, timedelta
from ..database import get_database
from ..settings import get_settings

settings = get_settings()


async def start_cleanup_tasks():
    """Start cleanup tasks"""
    print("🧹 Starting cleanup tasks...")
    asyncio.create_task(log_cleanup_task())
    asyncio.create_task(session_cleanup_task())
    asyncio.create_task(temp_data_cleanup_task())
    print("✅ Cleanup tasks started")


async def log_cleanup_task():
    """Clean up old log entries"""
    while True:
        try:
            await asyncio.sleep(3600)  # Run every hour

            db = get_database()
            cutoff = datetime.utcnow() - timedelta(days=30)  # Keep logs for 30 days

            # Clean system logs
            result = await db.system_logs.delete_many({"timestamp": {"$lt": cutoff}})
            if result.deleted_count > 0:
                print(f"🧹 Cleaned {result.deleted_count} old system logs")

            # Clean blocked packets
            result = await db.blocked_packets.delete_many({"timestamp": {"$lt": cutoff}})
            if result.deleted_count > 0:
                print(f"🧹 Cleaned {result.deleted_count} old blocked packet logs")

            # Clean resolved security alerts (keep for 7 days after resolution)
            alert_cutoff = datetime.utcnow() - timedelta(days=7)
            result = await db.security_alerts.delete_many({
                "resolved": True,
                "resolved_at": {"$lt": alert_cutoff}
            })
            if result.deleted_count > 0:
                print(f"🧹 Cleaned {result.deleted_count} old security alerts")

        except Exception as e:
            print(f"⚠️ Error in log cleanup: {e}")
            await asyncio.sleep(3600)


async def session_cleanup_task():
    """Clean up expired sessions"""
    while True:
        try:
            await asyncio.sleep(1800)  # Run every 30 minutes

            from ..dependencies import security_manager

            # Clean expired sessions from memory
            current_time = datetime.utcnow()
            expired_sessions = []

            for user_id, session_data in security_manager.active_sessions.items():
                last_activity = session_data.get("last_activity")
                if last_activity and (current_time - last_activity).total_seconds() > 28800:  # 8 hours
                    expired_sessions.append(user_id)

            for user_id in expired_sessions:
                security_manager.remove_session(user_id)

            if expired_sessions:
                print(f"🧹 Cleaned {len(expired_sessions)} expired sessions")

        except Exception as e:
            print(f"⚠️ Error in session cleanup: {e}")
            await asyncio.sleep(1800)


async def temp_data_cleanup_task():
    """Clean up temporary data"""
    while True:
        try:
            await asyncio.sleep(86400)  # Run daily

            db = get_database()

            # Clean old health records (keep only 7 days)
            cutoff = datetime.utcnow() - timedelta(days=7)

            collections_to_clean = [
                "system_health",
                "database_health",
                "performance_metrics"
            ]

            for collection_name in collections_to_clean:
                try:
                    result = await db[collection_name].delete_many({"timestamp": {"$lt": cutoff}})
                    if result.deleted_count > 0:
                        print(f"🧹 Cleaned {result.deleted_count} old records from {collection_name}")
                except Exception as e:
                    print(f"⚠️ Error cleaning {collection_name}: {e}")

            # Clean up failed authentication attempts (reset daily)
            from ..dependencies import security_manager
            security_manager.failed_attempts.clear()
            security_manager.blocked_ips.clear()
            print("🧹 Reset failed authentication attempts")

        except Exception as e:
            print(f"⚠️ Error in temp data cleanup: {e}")
            await asyncio.sleep(86400)


================================================
File: app/tasks/firewall_sync.py
================================================
"""
Firewall synchronization tasks
"""
import asyncio
import platform
from typing import Dict, Any
from ..firewall_os import add_firewall_rule_os, remove_firewall_rule_os, update_firewall_rule_os


async def sync_rule_to_os(rule_doc: Dict[str, Any]) -> bool:
    """
    Sync firewall rule to operating system
    """
    try:
        # Format rule for OS
        formatted_rule = {
            "rule_name": rule_doc.get("rule_name", ""),
            "source_ips": rule_doc.get("source_ips", []),
            "destination_ips": rule_doc.get("destination_ips", []),
            "source_ports": rule_doc.get("source_ports", []),
            "destination_ports": rule_doc.get("destination_ports", []),
            "protocol": rule_doc.get("protocol", "ANY"),
            "action": rule_doc.get("action", "ALLOW"),
            "direction": rule_doc.get("direction", "IN"),
            "enabled": rule_doc.get("enabled", True),
            "priority": rule_doc.get("priority", 100),
            "profile": rule_doc.get("profile", "Any"),
            "description": rule_doc.get("description", ""),
            "port": rule_doc.get("destination_ports", [None])[0] if rule_doc.get("destination_ports") else None
        }

        # Run in thread pool to avoid blocking
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(None, add_firewall_rule_os, formatted_rule)

        print(f"✅ Rule synced to OS: {rule_doc.get('rule_name')}")
        return True

    except Exception as e:
        print(f"❌ Failed to sync rule to OS: {rule_doc.get('rule_name')} - {e}")
        return False


async def remove_rule_from_os(rule_doc: Dict[str, Any]) -> bool:
    """
    Remove firewall rule from operating system
    """
    try:
        rule_name = rule_doc.get("rule_name", "")
        if not rule_name:
            return False

        # Run in thread pool to avoid blocking
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(None, remove_firewall_rule_os, rule_name)

        print(f"✅ Rule removed from OS: {rule_name}")
        return True

    except Exception as e:
        print(f"❌ Failed to remove rule from OS: {rule_doc.get('rule_name')} - {e}")
        return False


async def update_rule_in_os(old_rule: Dict[str, Any], new_rule: Dict[str, Any]) -> bool:
    """
    Update firewall rule in operating system
    """
    try:
        # Format old rule
        old_formatted = {
            "rule_name": old_rule.get("rule_name", ""),
            "source_ips": old_rule.get("source_ips", []),
            "port": old_rule.get("destination_ports", [None])[0] if old_rule.get("destination_ports") else None,
            "protocol": old_rule.get("protocol", "ANY"),
            "action": old_rule.get("action", "ALLOW"),
            "direction": old_rule.get("direction", "IN")
        }

        # Format new rule
        new_formatted = {
            "rule_name": new_rule.get("rule_name", ""),
            "source_ips": new_rule.get("source_ips", []),
            "destination_ips": new_rule.get("destination_ips", []),
            "source_ports": new_rule.get("source_ports", []),
            "destination_ports": new_rule.get("destination_ports", []),
            "protocol": new_rule.get("protocol", "ANY"),
            "action": new_rule.get("action", "ALLOW"),
            "direction": new_rule.get("direction", "IN"),
            "enabled": new_rule.get("enabled", True),
            "priority": new_rule.get("priority", 100),
            "profile": new_rule.get("profile", "Any"),
            "description": new_rule.get("description", ""),
            "port": new_rule.get("destination_ports", [None])[0] if new_rule.get("destination_ports") else None
        }

        # Run in thread pool to avoid blocking
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(None, update_firewall_rule_os, old_formatted, new_formatted)

        print(f"✅ Rule updated in OS: {new_rule.get('rule_name')}")
        return True

    except Exception as e:
        print(f"❌ Failed to update rule in OS: {new_rule.get('rule_name')} - {e}")
        return False


================================================
File: app/tasks/health_monitor.py
================================================
"""
System health monitoring tasks
"""
import asyncio
import psutil
from datetime import datetime, timedelta
from ..database import get_database


async def start_health_monitor():
    """Start system health monitoring"""
    print("💓 Starting health monitor...")
    asyncio.create_task(system_health_task())
    asyncio.create_task(database_health_task())
    print("✅ Health monitor started")


async def system_health_task():
    """Monitor system health metrics"""
    while True:
        try:
            # Collect system metrics
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')

            db = get_database()

            # Create health record
            health_doc = {
                "timestamp": datetime.utcnow(),
                "cpu_usage": cpu_percent,
                "memory_usage": memory.percent,
                "disk_usage": disk.percent,
                "memory_available": memory.available,
                "disk_free": disk.free,
                "source": "system_monitor"
            }

            # Store in database (keep only last 24 hours)
            await db.system_health.insert_one(health_doc)

            # Clean old records
            cutoff = datetime.utcnow() - timedelta(hours=24)
            await db.system_health.delete_many({"timestamp": {"$lt": cutoff}})

            # Check for alerts
            if cpu_percent > 90:
                await create_health_alert("high_cpu", "HIGH", f"CPU usage is {cpu_percent}%")
            elif memory.percent > 90:
                await create_health_alert("high_memory", "HIGH", f"Memory usage is {memory.percent}%")
            elif disk.percent > 90:
                await create_health_alert("high_disk", "MEDIUM", f"Disk usage is {disk.percent}%")

            await asyncio.sleep(60)  # Check every minute

        except Exception as e:
            print(f"⚠️ Error in system health monitoring: {e}")
            await asyncio.sleep(60)


async def database_health_task():
    """Monitor database health"""
    while True:
        try:
            db = get_database()

            # Test database connection
            start_time = datetime.utcnow()
            await db.command('ping')
            response_time = (datetime.utcnow() - start_time).total_seconds() * 1000

            # Create database health record
            health_doc = {
                "timestamp": datetime.utcnow(),
                "response_time_ms": response_time,
                "status": "healthy",
                "source": "database_monitor"
            }

            await db.database_health.insert_one(health_doc)

            # Check for slow response
            if response_time > 1000:  # 1 second
                await create_health_alert(
                    "slow_database",
                    "MEDIUM",
                    f"Database response time is {response_time:.2f}ms"
                )

            # Clean old records
            cutoff = datetime.utcnow() - timedelta(hours=24)
            await db.database_health.delete_many({"timestamp": {"$lt": cutoff}})

            await asyncio.sleep(300)  # Check every 5 minutes

        except Exception as e:
            print(f"⚠️ Error in database health monitoring: {e}")
            await asyncio.sleep(300)


async def create_health_alert(alert_type: str, severity: str, description: str):
    """Create a health-related alert"""
    try:
        db = get_database()

        # Check if similar alert already exists in last 10 minutes
        cutoff = datetime.utcnow() - timedelta(minutes=10)
        existing_alert = await db.security_alerts.find_one({
            "alert_type": alert_type,
            "timestamp": {"$gte": cutoff},
            "resolved": False
        })

        if existing_alert:
            return  # Don't create duplicate alerts

        alert_doc = {
            "timestamp": datetime.utcnow(),
            "alert_type": alert_type,
            "severity": severity,
            "title": f"System Health Alert: {alert_type.replace('_', ' ').title()}",
            "description": description,
            "acknowledged": False,
            "resolved": False,
            "source": "health_monitor",
            "metadata": {
                "category": "system_health"
            }
        }

        await db.security_alerts.insert_one(alert_doc)
        print(f"🚨 Health alert: {alert_type} - {description}")

    except Exception as e:
        print(f"⚠️ Error creating health alert: {e}")


================================================
File: app/tasks/log_watcher.py
================================================
"""
Log monitoring and analysis tasks
"""
import asyncio
import re
import platform
import subprocess
from datetime import datetime, timedelta
from ..database import get_database

FWDROP_REGEX = re.compile(r"FWDROP:")


async def start_log_watchers():
    """Start all log monitoring tasks"""
    print("🔍 Starting log watchers...")

    # Start different watchers based on platform
    if platform.system().lower().startswith("linux"):
        asyncio.create_task(iptables_log_watcher())
    elif platform.system().lower().startswith("win"):
        asyncio.create_task(windows_firewall_log_watcher())

    # Start analysis tasks
    asyncio.create_task(advanced_log_analysis_task())
    asyncio.create_task(security_alert_task())

    print("✅ Log watchers started")


async def iptables_log_watcher():
    """
    Monitor iptables logs for blocked packets (Linux only)
    """
    try:
        if not platform.system().lower().startswith("linux"):
            return

        print("🔍 Starting iptables log watcher...")

        # Try to monitor syslog
        cmd = ["tail", "-F", "/var/log/syslog"]
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            text=True
        )

        while True:
            try:
                line = await asyncio.wait_for(process.stdout.readline(), timeout=1.0)
                if not line:
                    await asyncio.sleep(0.1)
                    continue

                if "FWDROP:" in line:
                    await process_blocked_packet_log(line.strip())

            except asyncio.TimeoutError:
                continue
            except Exception as e:
                print(f"⚠️ Error in iptables log watcher: {e}")
                await asyncio.sleep(5)

    except Exception as e:
        print(f"❌ Failed to start iptables log watcher: {e}")


async def windows_firewall_log_watcher():
    """
    Monitor Windows Firewall logs for blocked packets
    """
    try:
        print("🔍 Starting Windows firewall log watcher...")

        # Windows firewall log is typically at:
        # %systemroot%\system32\LogFiles\Firewall\pfirewall.log
        import os
        log_path = os.path.join(
            os.environ.get('SYSTEMROOT', r'C:\Windows'),
            'system32', 'LogFiles', 'Firewall', 'pfirewall.log'
        )

        if not os.path.exists(log_path):
            print(f"⚠️ Windows Firewall log not found at: {log_path}")
            return

        # Simple file monitoring (in production, use a proper file watcher)
        last_size = 0
        while True:
            try:
                current_size = os.path.getsize(log_path)
                if current_size > last_size:
                    with open(log_path, 'r', encoding='utf-8', errors='ignore') as f:
                        f.seek(last_size)
                        new_lines = f.readlines()

                    for line in new_lines:
                        if 'DROP' in line.upper():
                            await process_blocked_packet_log(line.strip())

                    last_size = current_size

                await asyncio.sleep(5)  # Check every 5 seconds

            except Exception as e:
                print(f"⚠️ Error reading Windows firewall log: {e}")
                await asyncio.sleep(10)

    except Exception as e:
        print(f"❌ Failed to start Windows firewall log watcher: {e}")


async def process_blocked_packet_log(log_line: str):
    """Process a blocked packet log entry"""
    try:
        db = get_database()

        # Create blocked packet entry
        doc = {
            "timestamp": datetime.utcnow(),
            "raw_log_line": log_line,
            "source": "firewall_log",
            "event_type": "packet_blocked"
        }

        # Try to extract IP addresses from log
        import re
        ip_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
        ips = re.findall(ip_pattern, log_line)
        if ips:
            doc["source_ip"] = ips[0] if len(ips) > 0 else None
            doc["destination_ip"] = ips[1] if len(ips) > 1 else None

        await db.blocked_packets.insert_one(doc)

        # Check for alerts
        await check_blocked_alarm()

    except Exception as e:
        print(f"⚠️ Error processing blocked packet log: {e}")


async def check_blocked_alarm():
    """
    Check if there are too many blocked packets and create alerts
    """
    try:
        db = get_database()
        now = datetime.utcnow()
        cutoff = now - timedelta(minutes=5)

        # Count blocked packets in last 5 minutes
        count_last_5min = await db.blocked_packets.count_documents({
            "timestamp": {"$gte": cutoff}
        })

        if count_last_5min > 50:
            # Create security alert
            alert_doc = {
                "timestamp": now,
                "alert_type": "high_blocked_traffic",
                "severity": "HIGH",
                "title": "High Volume of Blocked Traffic",
                "description": f"Detected {count_last_5min} blocked packets in the last 5 minutes",
                "acknowledged": False,
                "resolved": False,
                "metadata": {
                    "blocked_count": count_last_5min,
                    "time_window": "5_minutes"
                }
            }
            await db.security_alerts.insert_one(alert_doc)
            print(f"🚨 Security alert: {count_last_5min} blocked packets in 5 minutes")

    except Exception as e:
        print(f"⚠️ Error checking blocked packet alarm: {e}")


async def advanced_log_analysis_task():
    """
    Advanced log analysis task that runs periodically
    """
    while True:
        try:
            await asyncio.sleep(300)  # Run every 5 minutes

            db = get_database()
            now = datetime.utcnow()
            cutoff = now - timedelta(minutes=10)

            # Count various log types
            query = {
                "timestamp": {"$gte": cutoff},
                "level": {"$in": ["ERROR", "WARNING"]},
                "message": {"$regex": "DENY|DROP|BLOCK", "$options": "i"}
            }

            count_deny = await db.system_logs.count_documents(query)

            if count_deny > 100:
                alert_doc = {
                    "timestamp": now,
                    "alert_type": "high_deny_activity",
                    "severity": "MEDIUM",
                    "title": "High Firewall Deny Activity",
                    "description": f"Detected {count_deny} DENY/DROP log entries in the last 10 minutes",
                    "acknowledged": False,
                    "resolved": False,
                    "metadata": {
                        "deny_count": count_deny,
                        "time_window": "10_minutes"
                    }
                }
                await db.security_alerts.insert_one(alert_doc)
                print(f"🚨 Alert: High deny activity - {count_deny} entries")

        except Exception as e:
            print(f"⚠️ Error in advanced log analysis: {e}")
            await asyncio.sleep(60)


async def security_alert_task():
    """
    General security monitoring task
    """
    while True:
        try:
            await asyncio.sleep(60)  # Run every minute

            db = get_database()
            now = datetime.utcnow()
            cutoff = now - timedelta(minutes=1)

            # Check for authentication failures
            auth_failures = await db.system_logs.count_documents({
                "timestamp": {"$gte": cutoff},
                "source": "auth",
                "level": "WARNING",
                "message": {"$regex": "failed|invalid", "$options": "i"}
            })

            if auth_failures > 10:
                alert_doc = {
                    "timestamp": now,
                    "alert_type": "authentication_failures",
                    "severity": "HIGH",
                    "title": "Multiple Authentication Failures",
                    "description": f"Detected {auth_failures} authentication failures in the last minute",
                    "acknowledged": False,
                    "resolved": False,
                    "metadata": {
                        "failure_count": auth_failures,
                        "time_window": "1_minute"
                    }
                }
                await db.security_alerts.insert_one(alert_doc)
                print(f"🚨 Security alert: {auth_failures} auth failures")

        except Exception as e:
            print(f"⚠️ Error in security alert task: {e}")
            await asyncio.sleep(30)




================================================
File: middleware/auth.js
================================================
import jwt from 'jsonwebtoken';
import { User } from '../models/User.js';
import { logger } from '../utils/logger.js';

// JWT Authentication middleware
export const auth = async (req, res, next) => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '');

    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'Token bulunamadı. Erişim reddedildi.'
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret-key-change-in-production');

    // Handle hardcoded admin user
    if (decoded.userId === 'admin-user-id') {
      req.user = {
        userId: 'admin-user-id',
        role: 'admin',
        username: 'admin'
      };
      return next();
    }

    // Try to find user in database
    try {
      const user = await User.findById(decoded.userId);
      if (!user || !user.isActive) {
        return res.status(401).json({
          success: false,
          message: 'Kullanıcı bulunamadı veya aktif değil'
        });
      }

      req.user = {
        userId: user._id,
        role: user.role,
        username: user.username
      };
    } catch (dbError) {
      console.log('⚠️ Database error in auth middleware:', dbError.message);
      // If database is down but token is valid, allow hardcoded admin
      if (decoded.userId === 'admin-user-id') {
        req.user = {
          userId: 'admin-user-id',
          role: 'admin',
          username: 'admin'
        };
      } else {
        return res.status(401).json({
          success: false,
          message: 'Veritabanı bağlantı hatası'
        });
      }
    }

    next();
  } catch (error) {
    logger.error('Auth middleware hatası:', error);

    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        success: false,
        message: 'Token süresi dolmuş'
      });
    }

    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({
        success: false,
        message: 'Geçersiz token'
      });
    }

    res.status(401).json({
      success: false,
      message: 'Token doğrulanamadı'
    });
  }
};


================================================
File: middleware/dataRetention.js
================================================
import { SystemStats } from '../models/SystemStats.js';
import { NetworkActivity } from '../models/NetworkActivity.js';
import { logger } from '../utils/logger.js';
import cron from 'node-cron';

class DataRetentionService {
  constructor() {
    this.isRunning = false;
  }

  // Veri saklama politikalarını başlat
  startRetentionPolicies() {
    if (this.isRunning) return;

    this.isRunning = true;
    logger.info('📅 Veri saklama politikaları başlatıldı');

    // Her gün gece 02:00'da eski verileri temizle
    cron.schedule('0 2 * * *', async () => {
      await this.cleanupOldData();
    }, {
      timezone: 'Europe/Istanbul'
    });

    // Her hafta pazar günü 03:00'da istatistikleri arşivle
    cron.schedule('0 3 * * 0', async () => {
      await this.archiveOldStats();
    }, {
      timezone: 'Europe/Istanbul'
    });

    // Her saat başı sistem sağlığını kontrol et
    cron.schedule('0 * * * *', async () => {
      await this.performHealthCheck();
    }, {
      timezone: 'Europe/Istanbul'
    });
  }

  // Eski verileri temizle
  async cleanupOldData() {
    try {
      logger.info('🧹 Eski veriler temizleniyor...');

      const now = new Date();

      // 30 günden eski network aktivitelerini sil
      const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      const deletedActivities = await NetworkActivity.deleteMany({
        timestamp: { $lt: thirtyDaysAgo }
      });

      // 90 günden eski sistem istatistiklerini sil
      const ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
      const deletedStats = await SystemStats.deleteMany({
        timestamp: { $lt: ninetyDaysAgo }
      });

      logger.info(`✅ Temizlik tamamlandı: ${deletedActivities.deletedCount} aktivite, ${deletedStats.deletedCount} istatistik silindi`);

    } catch (error) {
      logger.error('Veri temizleme hatası:', error);
    }
  }

  // Eski istatistikleri arşivle (opsiyonel)
  async archiveOldStats() {
    try {
      logger.info('📦 Eski veriler arşivleniyor...');

      const now = new Date();
      const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

      // Son 7 günden eski verileri summary olarak sakla
      const oldStats = await SystemStats.aggregate([
        {
          $match: {
            timestamp: { $lt: sevenDaysAgo }
          }
        },
        {
          $group: {
            _id: {
              year: { $year: '$timestamp' },
              month: { $month: '$timestamp' },
              day: { $dayOfMonth: '$timestamp' }
            },
            totalConnections: { $sum: '$totalConnections' },
            blockedConnections: { $sum: '$blockedConnections' },
            threats: { $sum: '$threats' },
            count: { $sum: 1 }
          }
        }
      ]);

      if (oldStats.length > 0) {
        logger.info(`📊 ${oldStats.length} günlük veri arşivlendi`);
      }

    } catch (error) {
      logger.error('Veri arşivleme hatası:', error);
    }
  }

  // Sistem sağlık kontrolü
  async performHealthCheck() {
    try {
      // Veritabanı bağlantısını kontrol et
      const dbStats = await SystemStats.collection.stats();
      const activityStats = await NetworkActivity.collection.stats();

      // Memory kullanımını kontrol et
      const memoryUsage = process.memoryUsage();
      const memoryUsagePercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100;

      // Kritik durum kontrolü
      if (memoryUsagePercent > 90) {
        logger.warn(`⚠️  Yüksek memory kullanımı: %${memoryUsagePercent.toFixed(1)}`);
      }

      // Veritabanı boyutu kontrolü
      const totalSize = dbStats.size + activityStats.size;
      const totalSizeMB = totalSize / (1024 * 1024);

      if (totalSizeMB > 1000) { // 1GB
        logger.warn(`⚠️  Veritabanı boyutu büyük: ${totalSizeMB.toFixed(1)} MB`);
      }

      logger.info(`💚 Sistem sağlık kontrolü tamamlandı - Memory: %${memoryUsagePercent.toFixed(1)}, DB: ${totalSizeMB.toFixed(1)} MB`);

    } catch (error) {
      logger.error('Sistem sağlık kontrolü hatası:', error);
    }
  }

  // Manuel temizlik
  async performManualCleanup(days = 30) {
    try {
      const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

      const deletedActivities = await NetworkActivity.deleteMany({
        timestamp: { $lt: cutoffDate }
      });

      const deletedStats = await SystemStats.deleteMany({
        timestamp: { $lt: cutoffDate }
      });

      logger.info(`🧹 Manuel temizlik: ${deletedActivities.deletedCount} aktivite, ${deletedStats.deletedCount} istatistik silindi`);

      return {
        deletedActivities: deletedActivities.deletedCount,
        deletedStats: deletedStats.deletedCount
      };

    } catch (error) {
      logger.error('Manuel temizlik hatası:', error);
      throw error;
    }
  }

  // Veri saklama politikalarını durdur
  stopRetentionPolicies() {
    this.isRunning = false;
    logger.info('📅 Veri saklama politikaları durduruldu');
  }
}

const dataRetentionService = new DataRetentionService();

export default dataRetentionService;


================================================
File: middleware/errorHandler.js
================================================
import { logger } from '../utils/logger.js';

export const errorHandler = (err, req, res, next) => {
  let error = { ...err };
  error.message = err.message;

  // Log error
  logger.error(err);

  // Mongoose bad ObjectId
  if (err.name === 'CastError') {
    const message = 'Kaynak bulunamadÄ±';
    error = { message, statusCode: 404 };
  }

  // Mongoose duplicate key
  if (err.code === 11000) {
    const field = Object.keys(err.keyValue)[0];
    const message = `Bu ${field} zaten kullanÄ±lÄ±yor`;
    error = { message, statusCode: 400 };
  }

  // Mongoose validation error
  if (err.name === 'ValidationError') {
    const message = Object.values(err.errors).map(val => val.message).join(', ');
    error = { message, statusCode: 400 };
  }

  // JWT errors
  if (err.name === 'JsonWebTokenError') {
    const message = 'GeÃ§ersiz token';
    error = { message, statusCode: 401 };
  }

  if (err.name === 'TokenExpiredError') {
    const message = 'Token sÃ¼resi dolmuÅŸ';
    error = { message, statusCode: 401 };
  }

  res.status(error.statusCode || 500).json({
    success: false,
    message: error.message || 'Sunucu hatasÄ±',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
};


================================================
File: models/FirewallRule.js
================================================
import mongoose from 'mongoose';

const firewallRuleSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    unique: true
  },
  description: String,
  isActive: {
    type: Boolean,
    default: true
  },
  priority: {
    type: Number,
    default: 100
  },
  source: {
    ip: String,
    subnet: String,
    port: String
  },
  destination: {
    ip: String,
    subnet: String,
    port: String
  },
  protocol: {
    type: String,
    enum: ['TCP', 'UDP', 'ICMP', 'ANY'],
    default: 'ANY'
  },
  action: {
    type: String,
    enum: ['allow', 'block', 'log'],
    required: true
  },
  schedule: {
    enabled: {
      type: Boolean,
      default: false
    },
    startTime: String,
    endTime: String,
    days: [String]
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  lastModified: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

firewallRuleSchema.index({ isActive: 1, priority: 1 });
firewallRuleSchema.index({ createdBy: 1 });

export const FirewallRule = mongoose.model('FirewallRule', firewallRuleSchema);


================================================
File: models/NetworkActivity.js
================================================
import mongoose from 'mongoose';

const networkActivitySchema = new mongoose.Schema({
  timestamp: {
    type: Date,
    default: Date.now,
    expires: 604800 // 7 gÃ¼n sonra otomatik silinir
  },
  sourceIp: {
    type: String,
    required: true
  },
  destinationIp: String,
  domain: String,
  port: {
    type: Number,
    required: true
  },
  protocol: {
    type: String,
    enum: ['TCP', 'UDP', 'ICMP'],
    default: 'TCP'
  },
  action: {
    type: String,
    enum: ['allowed', 'blocked', 'warning'],
    required: true
  },
  ruleId: String,
  reason: String,
  bytesTransferred: {
    type: Number,
    default: 0
  },
  threat: {
    detected: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      enum: ['malware', 'phishing', 'ddos', 'suspicious', 'none'],
      default: 'none'
    },
    severity: {
      type: String,
      enum: ['low', 'medium', 'high', 'critical'],
      default: 'low'
    }
  }
}, {
  timestamps: true
});

// Indexes
networkActivitySchema.index({ timestamp: -1 });
networkActivitySchema.index({ sourceIp: 1 });
networkActivitySchema.index({ action: 1 });
networkActivitySchema.index({ 'threat.detected': 1 });

export const NetworkActivity = mongoose.model('NetworkActivity', networkActivitySchema);


================================================
File: models/SystemStats.js
================================================
import mongoose from 'mongoose';

const systemStatsSchema = new mongoose.Schema({
  timestamp: {
    type: Date,
    default: Date.now,
    expires: 2592000 // 30 gÃ¼n sonra otomatik silinir
  },
  totalConnections: {
    type: Number,
    default: 0
  },
  blockedConnections: {
    type: Number,
    default: 0
  },
  allowedConnections: {
    type: Number,
    default: 0
  },
  threats: {
    type: Number,
    default: 0
  },
  activeRules: {
    type: Number,
    default: 0
  },
  connectedDevices: [{
    ip: String,
    mac: String,
    hostname: String,
    lastSeen: Date,
    status: {
      type: String,
      enum: ['active', 'inactive'],
      default: 'active'
    }
  }],
  networkActivity: [{
    hour: Number,
    totalConnections: Number,
    blockedConnections: Number,
    timestamp: Date
  }],
  systemStatus: {
    firewallActive: {
      type: Boolean,
      default: true
    },
    lastUpdate: {
      type: Date,
      default: Date.now
    },
    uptime: {
      type: Number,
      default: 0
    }
  }
}, {
  timestamps: true
});

// Indexes for better performance
systemStatsSchema.index({ timestamp: -1 });
systemStatsSchema.index({ 'connectedDevices.ip': 1 });

export const SystemStats = mongoose.model('SystemStats', systemStatsSchema);


================================================
File: models/User.js
================================================
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';
import validator from 'validator';

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: [true, 'KullanÄ±cÄ± adÄ± gerekli'],
    unique: true,
    trim: true,
    minlength: [3, 'KullanÄ±cÄ± adÄ± en az 3 karakter olmalÄ±'],
    maxlength: [20, 'KullanÄ±cÄ± adÄ± en fazla 20 karakter olmalÄ±'],
    match: [/^[a-zA-Z0-9_]+$/, 'KullanÄ±cÄ± adÄ± sadece harf, rakam ve alt Ã§izgi iÃ§erebilir']
  },
  email: {
    type: String,
    required: [true, 'E-posta gerekli'],
    unique: true,
    lowercase: true,
    validate: [validator.isEmail, 'GeÃ§erli bir e-posta adresi girin']
  },
  password: {
    type: String,
    required: [true, 'Parola gerekli'],
    minlength: [6, 'Parola en az 6 karakter olmalÄ±'],
    select: false
  },
  role: {
    type: String,
    enum: ['admin', 'operator', 'viewer'],
    default: 'viewer'
  },
  isActive: {
    type: Boolean,
    default: true
  },
  lastLogin: {
    type: Date
  },
  loginAttempts: {
    type: Number,
    default: 0
  },
  lockUntil: {
    type: Date
  },
  refreshTokens: [{
    token: String,
    createdAt: {
      type: Date,
      default: Date.now,
      expires: 604800 // 7 days
    }
  }],
  profile: {
    firstName: String,
    lastName: String,
    phone: String,
    department: String,
    avatar: String
  },
  preferences: {
    language: {
      type: String,
      default: 'tr'
    },
    theme: {
      type: String,
      enum: ['light', 'dark'],
      default: 'dark'
    },
    notifications: {
      email: {
        type: Boolean,
        default: true
      },
      browser: {
        type: Boolean,
        default: true
      }
    }
  }
}, {
  timestamps: true,
  toJSON: {
    transform: function(doc, ret) {
      delete ret.password;
      delete ret.refreshTokens;
      delete ret.loginAttempts;
      delete ret.lockUntil;
      return ret;
    }
  }
});

// Indexes
userSchema.index({ username: 1 });
userSchema.index({ email: 1 });
userSchema.index({ isActive: 1 });
userSchema.index({ role: 1 });

// Virtual for account lock status
userSchema.virtual('isLocked').get(function() {
  return !!(this.lockUntil && this.lockUntil > Date.now());
});

// Pre-save middleware to hash password
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();

  try {
    const saltRounds = parseInt(process.env.BCRYPT_SALT_ROUNDS) || 12;
    this.password = await bcrypt.hash(this.password, saltRounds);
    next();
  } catch (error) {
    next(error);
  }
});

// Method to compare password
userSchema.methods.comparePassword = async function(candidatePassword) {
  if (!this.password) return false;
  return await bcrypt.compare(candidatePassword, this.password);
};

// Method to increment login attempts
userSchema.methods.incLoginAttempts = function() {
  // If we have a previous lock that has expired, restart at 1
  if (this.lockUntil && this.lockUntil < Date.now()) {
    return this.updateOne({
      $unset: {
        lockUntil: 1
      },
      $set: {
        loginAttempts: 1
      }
    });
  }

  const updates = { $inc: { loginAttempts: 1 } };

  // If we have max attempts and it's not locked, lock the account
  if (this.loginAttempts + 1 >= 5 && !this.isLocked) {
    updates.$set = {
      lockUntil: Date.now() + 2 * 60 * 60 * 1000 // 2 hours
    };
  }

  return this.updateOne(updates);
};

// Method to reset login attempts
userSchema.methods.resetLoginAttempts = function() {
  return this.updateOne({
    $unset: {
      loginAttempts: 1,
      lockUntil: 1
    }
  });
};

// Static method to find by credentials
userSchema.statics.findByCredentials = async function(username, password) {
  const user = await this.findOne({
    $or: [
      { username: username },
      { email: username }
    ],
    isActive: true
  }).select('+password');

  if (!user) {
    throw new Error('GeÃ§ersiz kullanÄ±cÄ± adÄ± veya parola');
  }

  if (user.isLocked) {
    throw new Error('Hesap geÃ§ici olarak kilitlendi. LÃ¼tfen daha sonra tekrar deneyin.');
  }

  const isMatch = await user.comparePassword(password);

  if (!isMatch) {
    await user.incLoginAttempts();
    throw new Error('GeÃ§ersiz kullanÄ±cÄ± adÄ± veya parola');
  }

  // Reset login attempts on successful login
  if (user.loginAttempts > 0) {
    await user.resetLoginAttempts();
  }

  // Update last login
  user.lastLogin = new Date();
  await user.save();

  return user;
};

export const User = mongoose.model('User', userSchema);


================================================
File: routes/auth.js
================================================
import express from 'express';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import { body, validationResult } from 'express-validator';
import rateLimit from 'express-rate-limit';
import { User } from '../models/User.js';
import { auth } from '../middleware/auth.js';
import { logger } from '../utils/logger.js';

const router = express.Router();

// Rate limiting
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // limit each IP to 10 requests per windowMs
  message: {
    success: false,
    message: 'Çok fazla giriş denemesi. 15 dakika sonra tekrar deneyin.',
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Generate JWT tokens
const generateTokens = (userId) => {
  const accessToken = jwt.sign(
    { userId },
    process.env.JWT_SECRET || 'fallback-secret-key-change-in-production',
    { expiresIn: process.env.JWT_EXPIRES_IN || '24h' }
  );

  const refreshToken = jwt.sign(
    { userId },
    process.env.JWT_REFRESH_SECRET || 'fallback-refresh-secret-change-in-production',
    { expiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d' }
  );

  return { accessToken, refreshToken };
};

// Login validation
const loginValidation = [
  body('username')
    .trim()
    .notEmpty()
    .withMessage('Kullanıcı adı gerekli')
    .isLength({ min: 1 })
    .withMessage('Kullanıcı adı en az 1 karakter olmalı'),
  body('password')
    .notEmpty()
    .withMessage('Parola gerekli')
    .isLength({ min: 1 })
    .withMessage('Parola gerekli')
];

// @route   POST /api/auth/login
// @desc    Login user
// @access  Public
router.post('/login', authLimiter, loginValidation, async (req, res) => {
  try {
    console.log('🔐 Login attempt:', { username: req.body.username, ip: req.ip });

    // Validation check
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      console.log('❌ Validation errors:', errors.array());
      return res.status(400).json({
        success: false,
        message: 'Geçersiz giriş bilgileri',
        errors: errors.array()
      });
    }

    const { username, password, rememberMe } = req.body;

    // HARDCODED ADMIN USER FOR TESTING
    if (username === 'admin' && password === 'admin123') {
      console.log('✅ Hardcoded admin login successful');

      const { accessToken, refreshToken } = generateTokens('admin-user-id');

      const userData = {
        id: 'admin-user-id',
        username: 'admin',
        email: 'admin@localhost',
        role: 'admin',
        profile: {
          firstName: 'Admin',
          lastName: 'User'
        },
        preferences: {
          theme: 'dark',
          language: 'tr'
        }
      };

      logger.info(`Başarılı giriş: ${username} - IP: ${req.ip}`);

      return res.json({
        success: true,
        message: 'Giriş başarılı',
        token: accessToken,
        refreshToken: rememberMe ? refreshToken : undefined,
        user: userData
      });
    }

    // Try to find user in database
    let user;
    try {
      user = await User.findOne({
        $or: [
          { username: username },
          { email: username }
        ],
        isActive: true
      }).select('+password');

      console.log('👤 User found in DB:', !!user);
    } catch (dbError) {
      console.log('⚠️ Database query failed, falling back to hardcoded user');
      // Database connection might be down, but we can still allow hardcoded login
    }

    if (!user) {
      console.log('❌ User not found:', username);
      return res.status(401).json({
        success: false,
        message: 'Geçersiz kullanıcı adı veya parola'
      });
    }

    // Check password
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      console.log('❌ Password mismatch for user:', username);
      return res.status(401).json({
        success: false,
        message: 'Geçersiz kullanıcı adı veya parola'
      });
    }

    // Generate tokens
    const { accessToken, refreshToken } = generateTokens(user._id);

    // Save refresh token if remember me is checked
    if (rememberMe) {
      try {
        user.refreshTokens.push({
          token: refreshToken,
          createdAt: new Date()
        });
        await user.save();
      } catch (saveError) {
        console.log('⚠️ Failed to save refresh token:', saveError.message);
        // Continue anyway
      }
    }

    // Update last login
    try {
      user.lastLogin = new Date();
      await user.save();
    } catch (updateError) {
      console.log('⚠️ Failed to update last login:', updateError.message);
    }

    logger.info(`Başarılı giriş: ${user.username} - IP: ${req.ip}`);

    res.json({
      success: true,
      message: 'Giriş başarılı',
      token: accessToken,
      refreshToken: rememberMe ? refreshToken : undefined,
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        role: user.role,
        profile: user.profile,
        preferences: user.preferences
      }
    });
  } catch (error) {
    logger.error('Giriş hatası:', error);
    console.error('❌ Login error:', error);

    res.status(500).json({
      success: false,
      message: 'Giriş yapılırken bir hata oluştu'
    });
  }
});

// @route   GET /api/auth/verify
// @desc    Verify JWT token
// @access  Private
router.get('/verify', auth, async (req, res) => {
  try {
    // If using hardcoded admin
    if (req.user.userId === 'admin-user-id') {
      return res.json({
        success: true,
        user: {
          id: 'admin-user-id',
          username: 'admin',
          email: 'admin@localhost',
          role: 'admin'
        }
      });
    }

    const user = await User.findById(req.user.userId);
    if (!user || !user.isActive) {
      return res.status(401).json({
        success: false,
        message: 'Kullanıcı bulunamadı veya aktif değil'
      });
    }

    res.json({
      success: true,
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        role: user.role,
        profile: user.profile,
        preferences: user.preferences
      }
    });
  } catch (error) {
    logger.error('Token doğrulama hatası:', error);
    res.status(401).json({
      success: false,
      message: 'Token doğrulanamadı'
    });
  }
});

// @route   POST /api/auth/logout
// @desc    Logout user
// @access  Private
router.post('/logout', auth, async (req, res) => {
  try {
    console.log('🚪 Logout request from user:', req.user.userId);

    const { refreshToken } = req.body;

    if (refreshToken && req.user.userId !== 'admin-user-id') {
      // Remove refresh token from user (skip for hardcoded admin)
      try {
        await User.findByIdAndUpdate(req.user.userId, {
          $pull: { refreshTokens: { token: refreshToken } }
        });
      } catch (updateError) {
        console.log('⚠️ Failed to remove refresh token:', updateError.message);
      }
    }

    logger.info(`Kullanıcı çıkış yaptı: ${req.user.userId} - IP: ${req.ip}`);

    res.json({
      success: true,
      message: 'Başarıyla çıkış yapıldı'
    });
  } catch (error) {
    logger.error('Çıkış hatası:', error);
    res.status(500).json({
      success: false,
      message: 'Çıkış yapılırken bir hata oluştu'
    });
  }
});

export default router;


================================================
File: routes/dashboard.js
================================================
import express from 'express';
import { auth, authorize } from '../middleware/auth.js';
import { SystemStats } from '../models/SystemStats.js';
import { NetworkActivity } from '../models/NetworkActivity.js';
import { FirewallRule } from '../models/FirewallRule.js';
import dataCollectionService from '../services/dataCollectionService.js';
import dataRetentionService from '../middleware/dataRetention.js';
import { logger } from '../utils/logger.js';
import os from 'os';

const router = express.Router();

// @route   GET /api/dashboard/stats
// @desc    Get dashboard statistics (KALÄ°CÄ° VERÄ°LER)
// @access  Private
router.get('/stats', auth, async (req, res) => {
  try {
    const now = new Date();
    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    const lastMonth = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    // MongoDB'den gerÃ§ek verileri al
    const [
      totalConnections24h,
      blockedConnections24h,
      threats24h,
      totalConnectionsMonth,
      blockedConnectionsMonth,
      activeRules,
      latestSystemStats
    ] = await Promise.all([
      NetworkActivity.countDocuments({
        timestamp: { $gte: last24Hours }
      }),
      NetworkActivity.countDocuments({
        timestamp: { $gte: last24Hours },
        action: 'blocked'
      }),
      NetworkActivity.countDocuments({
        timestamp: { $gte: last24Hours },
        'threat.detected': true
      }),
      NetworkActivity.countDocuments({
        timestamp: { $gte: lastMonth }
      }),
      NetworkActivity.countDocuments({
        timestamp: { $gte: lastMonth },
        action: 'blocked'
      }),
      FirewallRule.countDocuments({ isActive: true }),
      SystemStats.findOne().sort({ createdAt: -1 }).limit(1)
    ]);

    // BÃ¼yÃ¼me oranÄ±nÄ± hesapla
    const dailyAvgThisMonth = totalConnectionsMonth / 30;
    const monthlyGrowth = dailyAvgThisMonth > 0
      ? ((totalConnections24h - dailyAvgThisMonth) / dailyAvgThisMonth * 100)
      : 0;

    // GÃ¼venlik seviyesini hesapla
    const securityLevel = totalConnections24h > 0
      ? (((totalConnections24h - blockedConnections24h) / totalConnections24h) * 100)
      : 100;

    // BaÄŸlÄ± cihazlarÄ± al
    const connectedDevices = latestSystemStats?.connectedDevices || [];

    const stats = {
      status: 'Aktif',
      connectedDevices: connectedDevices.length,
      activeRules,
      totalConnections: totalConnections24h,
      blocked: blockedConnections24h,
      threats: threats24h,
      lastUpdate: latestSystemStats?.systemStatus?.lastUpdate || new Date(),
      securityLevel: Math.max(0, Math.min(100, parseFloat(securityLevel.toFixed(1)))),
      monthlyGrowth: parseFloat(monthlyGrowth.toFixed(1)),
      uptime: Math.floor(os.uptime()),
      systemHealth: {
        cpu: await getCPUUsage(),
        memory: getMemoryUsage(),
        dataCollection: dataCollectionService.getSystemStatus()
      },
      // Ek istatistikler
      totalActivities: await NetworkActivity.countDocuments(),
      totalSystemStats: await SystemStats.countDocuments(),
      oldestActivity: await getOldestActivityDate(),
      newestActivity: await getNewestActivityDate()
    };

    res.json({
      success: true,
      data: stats,
      meta: {
        dataSource: 'mongodb',
        persistent: true,
        lastUpdated: new Date()
      }
    });
  } catch (error) {
    logger.error('Dashboard stats error:', error);
    res.status(500).json({
      success: false,
      message: 'Ä°statistikler alÄ±namadÄ±'
    });
  }
});

// @route   GET /api/dashboard/chart-data
// @desc    Get chart data for analytics (KALÄ°CÄ° VERÄ°LER)
// @access  Private
router.get('/chart-data', auth, async (req, res) => {
  try {
    const { period = '24h' } = req.query;
    let startTime, groupBy, dateFormat;

    switch (period) {
      case '7d':
        startTime = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        groupBy = {
          $dateToString: {
            format: '%Y-%m-%d',
            date: '$timestamp',
            timezone: 'Europe/Istanbul'
          }
        };
        dateFormat = '%d.%m';
        break;
      case '30d':
        startTime = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
        groupBy = {
          $dateToString: {
            format: '%Y-%m-%d',
            date: '$timestamp',
            timezone: 'Europe/Istanbul'
          }
        };
        dateFormat = '%d.%m';
        break;
      default: // 24h
        startTime = new Date(Date.now() - 24 * 60 * 60 * 1000);
        groupBy = {
          $dateToString: {
            format: '%H:00',
            date: '$timestamp',
            timezone: 'Europe/Istanbul'
          }
        };
        dateFormat = '%H:00';
    }

    // MongoDB'den gerÃ§ek verileri aggregate et
    const chartData = await NetworkActivity.aggregate([
      {
        $match: {
          timestamp: { $gte: startTime }
        }
      },
      {
        $group: {
          _id: groupBy,
          totalConnections: { $sum: 1 },
          blockedConnections: {
            $sum: {
              $cond: [{ $eq: ['$action', 'blocked'] }, 1, 0]
            }
          },
          allowedConnections: {
            $sum: {
              $cond: [{ $eq: ['$action', 'allowed'] }, 1, 0]
            }
          },
          threats: {
            $sum: {
              $cond: [{ $eq: ['$threat.detected', true] }, 1, 0]
            }
          }
        }
      },
      {
        $sort: { _id: 1 }
      }
    ]);

    // Eksik zaman dilimlerini sÄ±fÄ±r deÄŸerlerle doldur
    const filledData = fillMissingPeriods(chartData, period);

    res.json({
      success: true,
      data: filledData,
      meta: {
        period,
        dataPoints: filledData.length,
        dataSource: 'mongodb',
        persistent: true
      }
    });
  } catch (error) {
    logger.error('Chart data error:', error);
    res.status(500).json({
      success: false,
      message: 'Grafik verileri alÄ±namadÄ±'
    });
  }
});

// @route   GET /api/dashboard/recent-activity
// @desc    Get recent network activities (KALÄ°CÄ° VERÄ°LER)
// @access  Private
router.get('/recent-activity', auth, async (req, res) => {
  try {
    const { limit = 10 } = req.query;

    // MongoDB'den en son aktiviteleri al
    const activities = await NetworkActivity.find()
      .sort({ timestamp: -1 })
      .limit(parseInt(limit))
      .select('sourceIp destinationIp domain port action threat timestamp');

    const formattedActivities = activities.map(activity => ({
      id: activity._id,
      type: activity.action,
      domain: activity.domain || `${activity.destinationIp}:${activity.port}`,
      ip: activity.sourceIp,
      port: activity.port,
      timestamp: activity.timestamp,
      threat: activity.threat
    }));

    res.json({
      success: true,
      data: formattedActivities,
      meta: {
        total: await NetworkActivity.countDocuments(),
        dataSource: 'mongodb',
        persistent: true
      }
    });
  } catch (error) {
    logger.error('Recent activity error:', error);
    res.status(500).json({
      success: false,
      message: 'Son etkinlikler alÄ±namadÄ±'
    });
  }
});

// @route   GET /api/dashboard/data-status
// @desc    Get data persistence status
// @access  Private
router.get('/data-status', auth, async (req, res) => {
  try {
    const [
      totalActivities,
      totalStats,
      oldestActivity,
      newestActivity,
      dbStats
    ] = await Promise.all([
      NetworkActivity.countDocuments(),
      SystemStats.countDocuments(),
      NetworkActivity.findOne().sort({ timestamp: 1 }),
      NetworkActivity.findOne().sort({ timestamp: -1 }),
      NetworkActivity.collection.stats()
    ]);

    const systemStatus = dataCollectionService.getSystemStatus();

    res.json({
      success: true,
      data: {
        persistence: {
          enabled: true,
          dataCollection: systemStatus.isCollecting,
          totalActivities,
          totalStats,
          oldestRecord: oldestActivity?.timestamp,
          newestRecord: newestActivity?.timestamp,
          databaseSize: Math.round(dbStats.size / 1024 / 1024), // MB
          systemUptime: systemStatus.uptime
        },
        storage: {
          mongodb: true,
          retentionPolicy: '30 gÃ¼n (aktiviteler), 90 gÃ¼n (istatistikler)',
          autoCleanup: true,
          archiving: true
        }
      }
    });
  } catch (error) {
    logger.error('Data status error:', error);
    res.status(500).json({
      success: false,
      message: 'Veri durumu alÄ±namadÄ±'
    });
  }
});

// @route   GET /api/dashboard/reports-data
// @desc    Get reports data for frontend
// @access  Private
router.get('/reports-data', auth, async (req, res) => {
  try {
    const { filter = 'Son 30 gÃ¼n' } = req.query;

    // Calculate time range
    let startTime;
    const now = new Date();
    switch (filter) {
      case 'BugÃ¼n':
        startTime = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        break;
      case 'DÃ¼n':
        startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        break;
      case 'Son 3 gÃ¼n':
        startTime = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000);
        break;
      case 'Son 1 hafta':
        startTime = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case 'Son 2 hafta':
        startTime = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
        break;
      case 'Son 3 hafta':
        startTime = new Date(now.getTime() - 21 * 24 * 60 * 60 * 1000);
        break;
      case 'Son 60 gÃ¼n':
        startTime = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000);
        break;
      default: // Son 30 gÃ¼n
        startTime = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    }

    // Get real data from MongoDB
    const [totalActivities, blockedActivities, securityAlerts] = await Promise.all([
      NetworkActivity.countDocuments({ timestamp: { $gte: startTime } }),
      NetworkActivity.countDocuments({
        timestamp: { $gte: startTime },
        action: 'blocked'
      }),
      NetworkActivity.countDocuments({
        timestamp: { $gte: startTime },
        'threat.detected': true
      })
    ]);

    // Calculate uptime
    const uptimeSeconds = Math.floor(os.uptime());
    const uptimeDays = Math.floor(uptimeSeconds / 86400);
    const uptimeHours = Math.floor((uptimeSeconds % 86400) / 3600);

    // Prepare response data
    const reportsData = {
      totalTraffic: '2.4 TB',
      trafficGrowth: '+12',
      systemAttempts: blockedActivities.toString(),
      attemptsGrowth: '-8',
      blockedRequests: `${securityAlerts.toLocaleString()}`,
      blockedGrowth: '+3',
      systemUptime: `${uptimeDays} gÃ¼n ${uptimeHours} saat`,
      uptimePercentage: '99.8',
      securityReport: {
        attackAttempts: blockedActivities,
        blockedIPs: 12,
        topAttackedPorts: [
          { port: '22', service: 'SSH', attempts: 156 },
          { port: '80', service: 'HTTP', attempts: 89 },
          { port: '443', service: 'HTTPS', attempts: 34 }
        ]
      },
      quickStats: {
        dailyAverageTraffic: '80 GB',
        peakHour: '14:00-15:00',
        averageResponseTime: '12ms',
        successRate: '99.2%',
        securityScore: '8.7/10'
      },
      lastUpdate: new Date().toLocaleString('tr-TR')
    };

    res.json({
      success: true,
      data: reportsData,
      meta: {
        filter,
        dataSource: 'mongodb',
        generatedAt: new Date().toISOString()
      }
    });
  } catch (error) {
    logger.error('Reports data error:', error);
    res.status(500).json({
      success: false,
      message: 'Rapor verileri alÄ±namadÄ±'
    });
  }
});

// @route   POST /api/dashboard/manual-cleanup
// @desc    Manual data cleanup
// @access  Private (Admin only)
router.post('/manual-cleanup', auth, authorize('admin'), async (req, res) => {
  try {
    const { days = 30 } = req.body;
    const result = await dataRetentionService.performManualCleanup(days);

    res.json({
      success: true,
      message: `${days} gÃ¼nden eski veriler temizlendi`,
      data: result
    });
  } catch (error) {
    logger.error('Manual cleanup error:', error);
    res.status(500).json({
      success: false,
      message: 'Manuel temizlik baÅŸarÄ±sÄ±z'
    });
  }
});

// Helper Functions
async function getCPUUsage() {
  try {
    return Math.random() * 30 + 10; // Demo CPU usage
  } catch {
    return 0;
  }
}

function getMemoryUsage() {
  const totalMem = os.totalmem();
  const freeMem = os.freemem();
  const usedMem = totalMem - freeMem;

  return {
    total: Math.round(totalMem / 1024 / 1024), // MB
    used: Math.round(usedMem / 1024 / 1024), // MB
    percentage: Math.round((usedMem / totalMem) * 100)
  };
}

async function getOldestActivityDate() {
  try {
    const oldest = await NetworkActivity.findOne().sort({ timestamp: 1 });
    return oldest?.timestamp;
  } catch {
    return null;
  }
}

async function getNewestActivityDate() {
  try {
    const newest = await NetworkActivity.findOne().sort({ timestamp: -1 });
    return newest?.timestamp;
  } catch {
    return null;
  }
}

function fillMissingPeriods(data, period) {
  const filled = [];
  const now = new Date();

  if (period === '24h') {
    for (let i = 23; i >= 0; i--) {
      const hour = new Date(now.getTime() - i * 60 * 60 * 1000);
      const hourStr = hour.getHours().toString().padStart(2, '0') + ':00';
      const existingData = data.find(d => d._id === hourStr);

      filled.push({
        time: hourStr,
        totalConnections: existingData?.totalConnections || 0,
        blockedConnections: existingData?.blockedConnections || 0,
        allowedConnections: existingData?.allowedConnections || 0,
        threats: existingData?.threats || 0
      });
    }
  } else if (period === '7d') {
    for (let i = 6; i >= 0; i--) {
      const day = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
      const dayStr = day.toISOString().split('T')[0];
      const existingData = data.find(d => d._id === dayStr);

      filled.push({
        time: day.toLocaleDateString('tr-TR', { day: '2-digit', month: '2-digit' }),
        totalConnections: existingData?.totalConnections || 0,
        blockedConnections: existingData?.blockedConnections || 0,
        allowedConnections: existingData?.allowedConnections || 0,
        threats: existingData?.threats || 0
      });
    }
  } else if (period === '30d') {
    for (let i = 29; i >= 0; i--) {
      const day = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
      const dayStr = day.toISOString().split('T')[0];
      const existingData = data.find(d => d._id === dayStr);

      filled.push({
        time: day.toLocaleDateString('tr-TR', { day: '2-digit', month: '2-digit' }),
        totalConnections: existingData?.totalConnections || 0,
        blockedConnections: existingData?.blockedConnections || 0,
        allowedConnections: existingData?.allowedConnections || 0,
        threats: existingData?.threats || 0
      });
    }
  }

  return filled;
}

export default router;


================================================
File: routes/firewall.js
================================================
import express from 'express';
import { auth, authorize } from '../middleware/auth.js';
import { FirewallRule } from '../models/FirewallRule.js';
import { logger } from '../utils/logger.js';

const router = express.Router();

// @route   GET /api/firewall/rules
// @desc    Get all firewall rules
// @access  Private
router.get('/rules', auth, async (req, res) => {
  try {
    const { page = 1, limit = 10, active } = req.query;

    const query = {};
    if (active !== undefined) {
      query.isActive = active === 'true';
    }

    const rules = await FirewallRule.find(query)
      .populate('createdBy', 'username')
      .sort({ priority: 1, createdAt: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit);

    const total = await FirewallRule.countDocuments(query);

    res.json({
      success: true,
      data: {
        rules,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          pages: Math.ceil(total / limit)
        }
      }
    });

  } catch (error) {
    logger.error('Get firewall rules error:', error);
    res.status(500).json({
      success: false,
      message: 'Firewall kurallarÄ± alÄ±namadÄ±'
    });
  }
});

// @route   POST /api/firewall/rules
// @desc    Create firewall rule
// @access  Private (Admin only)
router.post('/rules', auth, authorize('admin'), async (req, res) => {
  try {
    const ruleData = {
      ...req.body,
      createdBy: req.user.userId
    };

    const rule = new FirewallRule(ruleData);
    await rule.save();

    logger.info(`Firewall kuralÄ± oluÅŸturuldu: ${rule.name} - ${req.user.username}`);

    res.status(201).json({
      success: true,
      message: 'Firewall kuralÄ± baÅŸarÄ±yla oluÅŸturuldu',
      data: rule
    });

  } catch (error) {
    logger.error('Create firewall rule error:', error);

    if (error.code === 11000) {
      return res.status(400).json({
        success: false,
        message: 'Bu isimde bir kural zaten mevcut'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Firewall kuralÄ± oluÅŸturulamadÄ±'
    });
  }
});

// Default rules oluÅŸturma endpoint'i
router.post('/initialize-rules', auth, authorize('admin'), async (req, res) => {
  try {
    const existingRules = await FirewallRule.countDocuments();

    if (existingRules > 0) {
      return res.json({
        success: true,
        message: 'Kurallar zaten mevcut'
      });
    }

    const defaultRules = [
      {
        name: 'Allow HTTP',
        description: 'HTTP trafiÄŸine izin ver',
        isActive: true,
        priority: 10,
        destination: { port: '80' },
        protocol: 'TCP',
        action: 'allow',
        createdBy: req.user.userId
      },
      {
        name: 'Allow HTTPS',
        description: 'HTTPS trafiÄŸine izin ver',
        isActive: true,
        priority: 20,
        destination: { port: '443' },
        protocol: 'TCP',
        action: 'allow',
        createdBy: req.user.userId
      },
      {
        name: 'Block Malware Sites',
        description: 'Bilinen kÃ¶tÃ¼ amaÃ§lÄ± siteleri engelle',
        isActive: true,
        priority: 5,
        source: { ip: 'any' },
        action: 'block',
        createdBy: req.user.userId
      },
      {
        name: 'Allow DNS',
        description: 'DNS sorgularÄ±na izin ver',
        isActive: true,
        priority: 15,
        destination: { port: '53' },
        protocol: 'UDP',
        action: 'allow',
        createdBy: req.user.userId
      },
      {
        name: 'Block SSH External',
        description: 'DÄ±ÅŸ SSH baÄŸlantÄ±larÄ±nÄ± engelle',
        isActive: true,
        priority: 30,
        destination: { port: '22' },
        protocol: 'TCP',
        action: 'block',
        createdBy: req.user.userId
      }
    ];

    await FirewallRule.insertMany(defaultRules);

    res.json({
      success: true,
      message: `${defaultRules.length} varsayÄ±lan kural oluÅŸturuldu`
    });

  } catch (error) {
    logger.error('Initialize rules error:', error);
    res.status(500).json({
      success: false,
      message: 'VarsayÄ±lan kurallar oluÅŸturulamadÄ±'
    });
  }
});

export default router;


================================================
File: routes/logs.js
================================================
const express = require('express');
const router = express.Router();

// Existing log routes...

// Clear logs
router.delete('/clear', async (req, res) => {
  try {
    console.log('Clearing logs');
    // Clear log files
    res.json({ message: 'Loglar temizlendi' });
  } catch (error) {
    console.error('Error clearing logs:', error);
    res.status(500).json({ error: 'Loglar temizlenirken hata oluÅŸtu' });
  }
});

module.exports = router;


================================================
File: routes/nat.js
================================================
const express = require('express');
const router = express.Router();
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

// Mock NAT settings
let natSettings = {
  enabled: false,
  wanInterface: '',
  lanInterface: ''
};

// Get NAT settings
router.get('/settings', async (req, res) => {
  try {
    res.json(natSettings);
  } catch (error) {
    console.error('Error fetching NAT settings:', error);
    res.status(500).json({ error: 'NAT ayarlarÄ± alÄ±nÄ±rken hata oluÅŸtu' });
  }
});

// Update NAT settings
router.put('/settings', async (req, res) => {
  try {
    natSettings = { ...natSettings, ...req.body };

    // Apply NAT configuration
    await applyNatConfiguration(natSettings);

    res.json(natSettings);
  } catch (error) {
    console.error('Error updating NAT settings:', error);
    res.status(500).json({ error: 'NAT ayarlarÄ± gÃ¼ncellenirken hata oluÅŸtu' });
  }
});

async function applyNatConfiguration(settings) {
  try {
    if (settings.enabled) {
      console.log(`Enabling NAT: WAN=${settings.wanInterface}, LAN=${settings.lanInterface}`);
      // Apply iptables rules for NAT
      // await execAsync(`iptables -t nat -A POSTROUTING -o ${settings.wanInterface} -j MASQUERADE`);
      // await execAsync(`iptables -A FORWARD -i ${settings.wanInterface} -o ${settings.lanInterface} -m state --state RELATED,ESTABLISHED -j ACCEPT`);
    } else {
      console.log('Disabling NAT');
      // Remove NAT rules
    }

    console.log('NAT configuration applied successfully');
  } catch (error) {
    console.error('Error applying NAT configuration:', error);
    throw error;
  }
}

module.exports = router;


================================================
File: routes/security.js
================================================
const express = require('express');
const router = express.Router();

// Get security status
router.get('/status', async (req, res) => {
  try {
    const securityStatus = {
      firewall: 'Aktif',
      ssl: 'GÃ¼ncel',
      lastScan: '2 saat Ã¶nce'
    };

    res.json(securityStatus);
  } catch (error) {
    console.error('Error fetching security status:', error);
    res.status(500).json({ error: 'GÃ¼venlik durumu alÄ±nÄ±rken hata oluÅŸtu' });
  }
});

module.exports = router;


================================================
File: routes/settings.js
================================================
const express = require('express');
const router = express.Router();
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

// Mock settings data
let settings = {
  timezone: 'TÃ¼rkiye (UTC+3)',
  language: 'TÃ¼rkÃ§e',
  sessionTimeout: '60',
  logLevel: 'Info (Normal)',
  autoUpdates: true,
  systemNotifications: true,
  darkTheme: true,
  backupFrequency: 'HaftalÄ±k',
  backupLocation: '/opt/firewall/backups'
};

// Get current settings
router.get('/', async (req, res) => {
  try {
    res.json(settings);
  } catch (error) {
    console.error('Error fetching settings:', error);
    res.status(500).json({ error: 'Ayarlar alÄ±nÄ±rken hata oluÅŸtu' });
  }
});

// Update settings
router.put('/', async (req, res) => {
  try {
    settings = { ...settings, ...req.body };

    // Apply system changes
    await applySystemSettings(settings);

    res.json(settings);
  } catch (error) {
    console.error('Error updating settings:', error);
    res.status(500).json({ error: 'Ayarlar gÃ¼ncellenirken hata oluÅŸtu' });
  }
});

async function applySystemSettings(settings) {
  try {
    // Apply timezone
    if (settings.timezone) {
      console.log(`Setting timezone: ${settings.timezone}`);
      // await execAsync(`timedatectl set-timezone Europe/Istanbul`);
    }

    // Apply other settings
    console.log('Settings applied successfully');
  } catch (error) {
    console.error('Error applying settings:', error);
    throw error;
  }
}

module.exports = router;


================================================
File: routes/system.js
================================================
const express = require('express');
const router = express.Router();
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

// Get system information
router.get('/info', async (req, res) => {
  try {
    const systemInfo = {
      version: '1.0.0',
      uptime: '2 gÃ¼n 14 saat',
      memoryUsage: 24,
      diskUsage: 45,
      totalMemory: '8 GB',
      totalDisk: '100 GB'
    };
    
    res.json(systemInfo);
  } catch (error) {
    console.error('Error fetching system info:', error);
    res.status(500).json({ error: 'Sistem bilgileri alÄ±nÄ±rken hata oluÅŸtu' });
  }
});

// Restart system
router.post('/restart', async (req, res) => {
  try {
    console.log('System restart initiated');
    // await execAsync('sudo reboot');
    res.json({ message: 'Sistem yeniden baÅŸlatÄ±lÄ±yor...' });
  } catch (error) {
    console.error('Error restarting system:', error);
    res.status(500).json({ error: 'Sistem yeniden baÅŸlatÄ±lÄ±rken hata oluÅŸtu' });
  }
});

// Create backup
router.post('/backup', async (req, res) => {
  try {
    console.log('Manual backup initiated');
    // Backup logic here
    res.json({ message: 'Manuel yedekleme baÅŸlatÄ±ldÄ±' });
  } catch (error) {
    console.error('Error creating backup:', error);
    res.status(500).json({ error: 'Yedekleme sÄ±rasÄ±nda hata oluÅŸtu' });
  }
});

// Check for updates
router.post('/check-updates', async (req, res) => {
  try {
    console.log('Checking for updates');
    // Update check logic here
    res.json({ message: 'GÃ¼ncellemeler kontrol ediliyor...' });
  } catch (error) {
    console.error('Error checking updates:', error);
    res.status(500).json({ error: 'GÃ¼ncellemeler kontrol edilirken hata oluÅŸtu' });
  }
});

module.exports = router;


================================================
File: routes/users.js
================================================
import express from 'express';
import { body, validationResult } from 'express-validator';
import { User } from '../models/User.js';
import { auth, authorize } from '../middleware/auth.js';
import { logger } from '../utils/logger.js';

const router = express.Router();

// @route   GET /api/users/profile
// @desc    Get current user profile
// @access  Private
router.get('/profile', auth, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'KullanÄ±cÄ± bulunamadÄ±'
      });
    }

    res.json({
      success: true,
      data: user
    });
  } catch (error) {
    logger.error('Profil getirme hatasÄ±:', error);
    res.status(500).json({
      success: false,
      message: 'Profil bilgileri alÄ±namadÄ±'
    });
  }
});

// @route   PUT /api/users/profile
// @desc    Update current user profile
// @access  Private
router.put('/profile', auth, [
  body('profile.firstName').optional().trim().isLength({ min: 2 }).withMessage('Ad en az 2 karakter olmalÄ±'),
  body('profile.lastName').optional().trim().isLength({ min: 2 }).withMessage('Soyad en az 2 karakter olmalÄ±'),
  body('profile.phone').optional().isMobilePhone('tr-TR').withMessage('GeÃ§erli bir telefon numarasÄ± girin'),
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'GeÃ§ersiz veriler',
        errors: errors.array()
      });
    }

    const { profile, preferences } = req.body;

    const user = await User.findByIdAndUpdate(
      req.user.userId,
      {
        $set: {
          ...(profile && { profile }),
          ...(preferences && { preferences })
        }
      },
      { new: true, runValidators: true }
    );

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'KullanÄ±cÄ± bulunamadÄ±'
      });
    }

    logger.info(`Profil gÃ¼ncellendi: ${user.username} - IP: ${req.ip}`);

    res.json({
      success: true,
      message: 'Profil baÅŸarÄ±yla gÃ¼ncellendi',
      data: user
    });
  } catch (error) {
    logger.error('Profil gÃ¼ncelleme hatasÄ±:', error);
    res.status(500).json({
      success: false,
      message: 'Profil gÃ¼ncellenirken bir hata oluÅŸtu'
    });
  }
});

// @route   GET /api/users
// @desc    Get all users (Admin only)
// @access  Private/Admin
router.get('/', auth, authorize('admin'), async (req, res) => {
  try {
    const { page = 1, limit = 10, search, role, isActive } = req.query;

    const query = {};

    if (search) {
      query.$or = [
        { username: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } },
        { 'profile.firstName': { $regex: search, $options: 'i' } },
        { 'profile.lastName': { $regex: search, $options: 'i' } }
      ];
    }

    if (role) query.role = role;
    if (isActive !== undefined) query.isActive = isActive === 'true';

    const users = await User.find(query)
      .limit(limit * 1)
      .skip((page - 1) * limit)
      .sort({ createdAt: -1 });

    const total = await User.countDocuments(query);

    res.json({
      success: true,
      data: {
        users,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          pages: Math.ceil(total / limit)
        }
      }
    });
  } catch (error) {
    logger.error('KullanÄ±cÄ± listesi hatasÄ±:', error);
    res.status(500).json({
      success: false,
      message: 'KullanÄ±cÄ± listesi alÄ±namadÄ±'
    });
  }
});

export default router;


================================================
File: services/dataCollectionService.js
================================================
import { SystemStats } from '../models/SystemStats.js';
import { NetworkActivity } from '../models/NetworkActivity.js';
import { FirewallRule } from '../models/FirewallRule.js';
import { logger } from '../utils/logger.js';
import os from 'os';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

class DataCollectionService {
  constructor() {
    this.isCollecting = false;
    this.collectionInterval = null;
    this.activityInterval = null;
  }

  // Sistem durumunu sürekli topla ve MongoDB'ye kaydet
  async startDataCollection() {
    if (this.isCollecting) {
      logger.info('Veri toplama zaten çalışıyor');
      return;
    }

    this.isCollecting = true;
    logger.info('🔄 Kalıcı veri toplama sistemi başlatıldı');

    // Her 5 dakikada bir sistem istatistiklerini kaydet
    this.collectionInterval = setInterval(async () => {
      await this.collectSystemStats();
    }, 5 * 60 * 1000); // 5 dakika

    // Her 30 saniyede bir network activity simüle et (gerçek sistemde bu gerçek trafik olacak)
    this.activityInterval = setInterval(async () => {
      await this.collectNetworkActivity();
    }, 30 * 1000); // 30 saniye

    // İlk veri toplamayı hemen başlat
    await this.collectSystemStats();
    await this.initializeDefaultData();
  }

  async stopDataCollection() {
    if (!this.isCollecting) return;

    this.isCollecting = false;

    if (this.collectionInterval) {
      clearInterval(this.collectionInterval);
      this.collectionInterval = null;
    }

    if (this.activityInterval) {
      clearInterval(this.activityInterval);
      this.activityInterval = null;
    }

    logger.info('⏹️  Veri toplama sistemi durduruldu');
  }

  // Sistem istatistiklerini topla ve kaydet
  async collectSystemStats() {
    try {
      const connectedDevices = await this.getConnectedDevices();
      const activeRulesCount = await FirewallRule.countDocuments({ isActive: true });

      // Son 1 saatteki aktiviteleri say
      const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
      const [totalConnections, blockedConnections, threats] = await Promise.all([
        NetworkActivity.countDocuments({ timestamp: { $gte: oneHourAgo } }),
        NetworkActivity.countDocuments({
          timestamp: { $gte: oneHourAgo },
          action: 'blocked'
        }),
        NetworkActivity.countDocuments({
          timestamp: { $gte: oneHourAgo },
          'threat.detected': true
        })
      ]);

      // Sistem istatistiklerini oluştur
      const systemStats = new SystemStats({
        totalConnections,
        blockedConnections,
        allowedConnections: totalConnections - blockedConnections,
        threats,
        activeRules: activeRulesCount,
        connectedDevices: connectedDevices.map(device => ({
          ip: device.ip,
          mac: device.mac,
          hostname: device.hostname,
          lastSeen: device.lastSeen,
          status: device.status
        })),
        networkActivity: await this.getHourlyActivity(),
        systemStatus: {
          firewallActive: true,
          lastUpdate: new Date(),
          uptime: os.uptime()
        }
      });

      await systemStats.save();
      logger.info(`📊 Sistem istatistikleri kaydedildi: ${totalConnections} bağlantı, ${blockedConnections} engelleme`);

    } catch (error) {
      logger.error('Sistem istatistikleri toplama hatası:', error);
    }
  }

  // Network aktivitesi simüle et ve kaydet
  async collectNetworkActivity() {
    try {
      // Gerçek sistemde bu gerçek network trafiğinden gelecek
      // Şimdilik simülasyon yapıyoruz
      const shouldCreateActivity = Math.random() > 0.3; // %70 ihtimalle aktivite oluştur

      if (!shouldCreateActivity) return;

      const domains = [
        'google.com', 'microsoft.com', 'github.com', 'stackoverflow.com', 'aws.amazon.com',
        'malicious-site.com', 'phishing-domain.net', 'suspicious-activity.org', 'threat-source.com'
      ];

      const sourceIPs = [
        '192.168.1.10', '192.168.1.15', '192.168.1.20', '192.168.1.25', '192.168.1.30',
        '10.0.0.5', '10.0.0.8', '10.0.0.12', '172.16.0.5', '172.16.0.10'
      ];

      const domain = domains[Math.floor(Math.random() * domains.length)];
      const sourceIp = sourceIPs[Math.floor(Math.random() * sourceIPs.length)];

      // Kötü amaçlı domain kontrolü
      const isMalicious = domain.includes('malicious') || domain.includes('phishing') ||
                         domain.includes('suspicious') || domain.includes('threat');

      const isBlocked = isMalicious || Math.random() > 0.85; // Kötü amaçlı siteler + %15 rastgele engelleme
      const hasThreat = isBlocked && Math.random() > 0.6; // Engellenen trafiğin %40'ında tehdit

      const activity = new NetworkActivity({
        sourceIp: sourceIp,
        destinationIp: `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
        domain: domain,
        port: this.getRandomPort(),
        protocol: ['TCP', 'UDP', 'ICMP'][Math.floor(Math.random() * 3)],
        action: isBlocked ? 'blocked' : 'allowed',
        ruleId: `rule_${Math.floor(Math.random() * 10) + 1}`,
        reason: isBlocked ? 'Security policy violation' : 'Traffic allowed by policy',
        bytesTransferred: Math.floor(Math.random() * 50000) + 1000,
        threat: {
          detected: hasThreat,
          type: hasThreat ? this.getThreatType() : 'none',
          severity: hasThreat ? this.getThreatSeverity() : 'low'
        }
      });

      await activity.save();

      // Kritik tehditler için log
      if (hasThreat && activity.threat.severity === 'critical') {
        logger.warn(`🚨 Kritik tehdit tespit edildi: ${domain} -> ${sourceIp}`);
      }

    } catch (error) {
      logger.error('Network aktivitesi kaydetme hatası:', error);
    }
  }

  // İlk kurulumda varsayılan veriler oluştur
  async initializeDefaultData() {
    try {
      // Eğer hiç sistem istatistiği yoksa, varsayılan oluştur
      const existingStats = await SystemStats.countDocuments();
      if (existingStats === 0) {
        logger.info('💾 İlk kurulum: Varsayılan sistem verileri oluşturuluyor...');

        // Son 24 saat için saatlik veri oluştur
        for (let i = 23; i >= 0; i--) {
          const timestamp = new Date(Date.now() - i * 60 * 60 * 1000);
          const totalConnections = Math.floor(Math.random() * 500) + 100;
          const blockedConnections = Math.floor(totalConnections * (Math.random() * 0.2 + 0.05));

          const stats = new SystemStats({
            timestamp,
            totalConnections,
            blockedConnections,
            allowedConnections: totalConnections - blockedConnections,
            threats: Math.floor(blockedConnections * 0.1),
            activeRules: 12,
            connectedDevices: await this.getConnectedDevices(),
            systemStatus: {
              firewallActive: true,
              lastUpdate: timestamp,
              uptime: os.uptime()
            }
          });

          await stats.save();
        }

        // Örnek network aktiviteleri oluştur
        await this.createSampleNetworkActivities();

        logger.info('✅ Varsayılan sistem verileri oluşturuldu');
      }

      // Varsayılan firewall kuralları oluştur
      await this.initializeFirewallRules();

    } catch (error) {
      logger.error('Varsayılan veri oluşturma hatası:', error);
    }
  }

  // Örnek network aktiviteleri oluştur (ilk kurulum için)
  async createSampleNetworkActivities() {
    const sampleActivities = [];
    const now = new Date();

    for (let i = 0; i < 50; i++) {
      const timestamp = new Date(now.getTime() - Math.random() * 24 * 60 * 60 * 1000); // Son 24 saat içinde
      const isBlocked = Math.random() > 0.8;
      const hasThreat = isBlocked && Math.random() > 0.7;

      sampleActivities.push({
        timestamp,
        sourceIp: `192.168.1.${Math.floor(Math.random() * 50) + 10}`,
        destinationIp: `8.8.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
        domain: this.getRandomDomain(),
        port: this.getRandomPort(),
        protocol: ['TCP', 'UDP'][Math.floor(Math.random() * 2)],
        action: isBlocked ? 'blocked' : 'allowed',
        ruleId: `rule_${Math.floor(Math.random() * 10) + 1}`,
        reason: isBlocked ? 'Security policy violation' : 'Traffic allowed',
        bytesTransferred: Math.floor(Math.random() * 10000) + 500,
        threat: {
          detected: hasThreat,
          type: hasThreat ? this.getThreatType() : 'none',
          severity: hasThreat ? this.getThreatSeverity() : 'low'
        }
      });
    }

    await NetworkActivity.insertMany(sampleActivities);
    logger.info(`📝 ${sampleActivities.length} örnek network aktivitesi oluşturuldu`);
  }

  // Varsayılan firewall kuralları oluştur
  async initializeFirewallRules() {
    try {
      const existingRules = await FirewallRule.countDocuments();
      if (existingRules > 0) return;

      // Sistem kullanıcısı ID'si (admin)
      const adminUser = await import('../models/User.js').then(module => module.User);
      const admin = await adminUser.findOne({ role: 'admin' });

      if (!admin) {
        logger.warn('Admin kullanıcısı bulunamadı, firewall kuralları oluşturulamadı');
        return;
      }

      const defaultRules = [
        {
          name: 'Allow HTTP Traffic',
          description: 'HTTP web trafiğine izin ver (port 80)',
          isActive: true,
          priority: 10,
          destination: { port: '80' },
          protocol: 'TCP',
          action: 'allow',
          createdBy: admin._id
        },
        {
          name: 'Allow HTTPS Traffic',
          description: 'HTTPS güvenli web trafiğine izin ver (port 443)',
          isActive: true,
          priority: 20,
          destination: { port: '443' },
          protocol: 'TCP',
          action: 'allow',
          createdBy: admin._id
        },
        {
          name: 'Block Malware Domains',
          description: 'Bilinen kötü amaçlı domain\'leri engelle',
          isActive: true,
          priority: 5,
          source: { ip: 'any' },
          action: 'block',
          createdBy: admin._id
        },
        {
          name: 'Allow DNS Queries',
          description: 'DNS sorgularına izin ver (port 53)',
          isActive: true,
          priority: 15,
          destination: { port: '53' },
          protocol: 'UDP',
          action: 'allow',
          createdBy: admin._id
        },
        {
          name: 'Block External SSH',
          description: 'Dış ağdan SSH bağlantılarını engelle (port 22)',
          isActive: true,
          priority: 30,
          destination: { port: '22' },
          protocol: 'TCP',
          action: 'block',
          createdBy: admin._id
        },
        {
          name: 'Allow FTP',
          description: 'FTP trafiğine izin ver (port 21)',
          isActive: false,
          priority: 40,
          destination: { port: '21' },
          protocol: 'TCP',
          action: 'allow',
          createdBy: admin._id
        },
        {
          name: 'Block P2P Traffic',
          description: 'BitTorrent ve P2P trafiğini engelle',
          isActive: true,
          priority: 25,
          destination: { port: '6881-6889' },
          protocol: 'TCP',
          action: 'block',
          createdBy: admin._id
        },
        {
          name: 'Allow Email SMTP',
          description: 'Email gönderimi için SMTP\'ye izin ver (port 587)',
          isActive: true,
          priority: 35,
          destination: { port: '587' },
          protocol: 'TCP',
          action: 'allow',
          createdBy: admin._id
        },
        {
          name: 'Allow Email IMAP',
          description: 'Email alımı için IMAP\'a izin ver (port 993)',
          isActive: true,
          priority: 36,
          destination: { port: '993' },
          protocol: 'TCP',
          action: 'allow',
          createdBy: admin._id
        },
        {
          name: 'Block Suspicious IPs',
          description: 'Şüpheli IP adreslerini engelle',
          isActive: true,
          priority: 3,
          source: { subnet: '10.0.0.0/8' },
          action: 'block',
          createdBy: admin._id
        },
        {
          name: 'Allow NTP',
          description: 'Zaman senkronizasyonu için NTP\'ye izin ver (port 123)',
          isActive: true,
          priority: 45,
          destination: { port: '123' },
          protocol: 'UDP',
          action: 'allow',
          createdBy: admin._id
        },
        {
          name: 'Block High Risk Ports',
          description: 'Yüksek riskli portları engelle',
          isActive: true,
          priority: 8,
          destination: { port: '1433,3389,5900' },
          protocol: 'TCP',
          action: 'block',
          createdBy: admin._id
        }
      ];

      await FirewallRule.insertMany(defaultRules);
      logger.info(`🛡️  ${defaultRules.length} varsayılan firewall kuralı oluşturuldu`);

    } catch (error) {
      logger.error('Varsayılan firewall kuralları oluşturma hatası:', error);
    }
  }

  // Helper methods
  async getConnectedDevices() {
    try {
      // Gerçek sistemde arp table veya DHCP lease'lerinden alınacak
      return [
        { ip: '192.168.1.10', mac: '00:11:22:33:44:55', hostname: 'admin-laptop', lastSeen: new Date(), status: 'active' },
        { ip: '192.168.1.15', mac: '00:11:22:33:44:56', hostname: 'server-001', lastSeen: new Date(), status: 'active' },
        { ip: '192.168.1.20', mac: '00:11:22:33:44:57', hostname: 'workstation-02', lastSeen: new Date(), status: 'active' },
        { ip: '192.168.1.25', mac: '00:11:22:33:44:58', hostname: 'mobile-device', lastSeen: new Date(), status: 'active' },
        { ip: '10.0.0.5', mac: '00:11:22:33:44:59', hostname: 'printer-hp', lastSeen: new Date(), status: 'active' }
      ];
    } catch (error) {
      logger.error('Bağlı cihazları alma hatası:', error);
      return [];
    }
  }

  async getHourlyActivity() {
    try {
      const now = new Date();
      const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);

      const hourlyData = await NetworkActivity.aggregate([
        {
          $match: {
            timestamp: { $gte: last24Hours }
          }
        },
        {
          $group: {
            _id: { $hour: '$timestamp' },
            totalConnections: { $sum: 1 },
            blockedConnections: {
              $sum: { $cond: [{ $eq: ['$action', 'blocked'] }, 1, 0] }
            }
          }
        },
        {
          $sort: { _id: 1 }
        }
      ]);

      return hourlyData.map(item => ({
        hour: item._id,
        totalConnections: item.totalConnections,
        blockedConnections: item.blockedConnections,
        timestamp: new Date()
      }));
    } catch (error) {
      logger.error('Saatlik aktivite verisi alma hatası:', error);
      return [];
    }
  }

  getRandomDomain() {
    const domains = [
      'google.com', 'microsoft.com', 'github.com', 'stackoverflow.com', 'netflix.com',
      'amazon.com', 'facebook.com', 'twitter.com', 'linkedin.com', 'youtube.com',
      'malware-site.com', 'phishing-domain.net', 'suspicious-activity.org'
    ];
    return domains[Math.floor(Math.random() * domains.length)];
  }

  getRandomPort() {
    const commonPorts = [80, 443, 22, 21, 25, 53, 110, 143, 993, 995, 587, 465, 8080, 8443, 3389, 5900];
    const useCommonPort = Math.random() > 0.3;

    if (useCommonPort) {
      return commonPorts[Math.floor(Math.random() * commonPorts.length)];
    } else {
      return Math.floor(Math.random() * 65535) + 1;
    }
  }

  getThreatType() {
    const types = ['malware', 'phishing', 'ddos', 'suspicious'];
    return types[Math.floor(Math.random() * types.length)];
  }

  getThreatSeverity() {
    const severities = ['low', 'medium', 'high', 'critical'];
    const weights = [0.4, 0.3, 0.2, 0.1]; // Düşük seviye daha olası

    const random = Math.random();
    let cumulative = 0;

    for (let i = 0; i < weights.length; i++) {
      cumulative += weights[i];
      if (random <= cumulative) {
        return severities[i];
      }
    }

    return 'low';
  }

  // Sistem durumunu al
  getSystemStatus() {
    return {
      isCollecting: this.isCollecting,
      uptime: os.uptime(),
      memory: process.memoryUsage(),
      platform: os.platform(),
      nodeVersion: process.version
    };
  }
}

// Singleton instance
const dataCollectionService = new DataCollectionService();

export default dataCollectionService;


================================================
File: utils/logger.js
================================================
import winston from 'winston';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create logs directory if it doesn't exist
import fs from 'fs';
const logsDir = path.join(__dirname, '../logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir, { recursive: true });
}

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp({
      format: 'YYYY-MM-DD HH:mm:ss'
    }),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'netgate-backend' },
  transports: [
    // Write all logs with level `error` and below to `error.log`
    new winston.transports.File({
      filename: path.join(logsDir, 'error.log'),
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    // Write all logs with level `info` and below to `combined.log`
    new winston.transports.File({
      filename: path.join(logsDir, 'combined.log'),
      maxsize: 5242880, // 5MB
      maxFiles: 5
    })
  ]
});

// If we're not in production then log to the `console` with the format:
// `${info.level}: ${info.message} JSON.stringify({ ...rest }) `
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple(),
      winston.format.printf(({ timestamp, level, message, service, ...meta }) => {
        return `${timestamp} [${service}] ${level}: ${message} ${
          Object.keys(meta).length ? JSON.stringify(meta, null, 2) : ''
        }`;
      })
    )
  }));
}

export { logger };

